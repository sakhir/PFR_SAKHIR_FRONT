var AccordionGroupComponent_1;
import { __decorate, __metadata } from "tslib";
import { AfterContentInit, AfterViewInit, ChangeDetectorRef, Component, ContentChild, ContentChildren, EventEmitter, Input, NgZone, OnChanges, OnDestroy, OnInit, Output, QueryList, Renderer2, SimpleChanges, TemplateRef, ViewChild, ViewChildren } from '@angular/core';
import { AccordionToggleDirective } from './accordion.directive';
import { removeListeners, removeSubscriptions } from '../helpers';
/*
 *
 */
let AccordionHeaderComponent = class AccordionHeaderComponent {
};
__decorate([
    ViewChild('templateRef', { static: true }),
    __metadata("design:type", TemplateRef)
], AccordionHeaderComponent.prototype, "templateRef", void 0);
AccordionHeaderComponent = __decorate([
    Component({
        selector: 'mk-accordion-header',
        template: '<ng-template #templateRef><ng-content></ng-content></ng-template>'
    })
], AccordionHeaderComponent);
export { AccordionHeaderComponent };
/*
 *
 */
let AccordionContentComponent = class AccordionContentComponent {
};
__decorate([
    ViewChild('templateRef', { static: true }),
    __metadata("design:type", TemplateRef)
], AccordionContentComponent.prototype, "templateRef", void 0);
AccordionContentComponent = __decorate([
    Component({
        selector: 'mk-accordion-content',
        template: '<ng-template #templateRef><ng-content></ng-content></ng-template>'
    })
], AccordionContentComponent);
export { AccordionContentComponent };
/*
 *
 */
let AccordionComponent = class AccordionComponent {
    constructor() {
        this.contentStyleClass = 'box-body';
        this.headerStyleClass = 'box-header with-border';
    }
    /**
     * @method ngOnInit
     */
    ngOnInit() {
        this.headerStyleColor = this.headerColor;
        if (!this.header && !this.accordionHeaderComponent) {
            throw new Error('Attribute "header" OR Component "mk-+accordion-header" is required for component "mk-+accordion"');
        }
        if (this.accordionContentComponent) {
            this.contentTemplateRef = this.accordionContentComponent.templateRef;
        }
        else {
            this.contentTemplateRef = this.templateRef;
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], AccordionComponent.prototype, "borderColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AccordionComponent.prototype, "contentColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AccordionComponent.prototype, "contentStyleClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AccordionComponent.prototype, "header", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AccordionComponent.prototype, "headerColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AccordionComponent.prototype, "headerColorHover", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AccordionComponent.prototype, "headerStyleClass", void 0);
__decorate([
    ContentChild(AccordionHeaderComponent, /* TODO: add static flag */ {}),
    __metadata("design:type", AccordionHeaderComponent)
], AccordionComponent.prototype, "accordionHeaderComponent", void 0);
__decorate([
    ContentChild(AccordionContentComponent, /* TODO: add static flag */ {}),
    __metadata("design:type", AccordionContentComponent)
], AccordionComponent.prototype, "accordionContentComponent", void 0);
__decorate([
    ViewChild('templateRef', { static: true }),
    __metadata("design:type", TemplateRef)
], AccordionComponent.prototype, "templateRef", void 0);
AccordionComponent = __decorate([
    Component({
        selector: 'mk-accordion',
        template: '<ng-template #templateRef><ng-content></ng-content></ng-template>'
    })
], AccordionComponent);
export { AccordionComponent };
/*
 *
 */
let AccordionGroupComponent = AccordionGroupComponent_1 = class AccordionGroupComponent {
    /**
     * @method constructor
     * @param changeDetectorRef [description]
     * @param ngZone            [description]
     * @param renderer2         [description]
     */
    constructor(changeDetectorRef, ngZone, renderer2) {
        this.changeDetectorRef = changeDetectorRef;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.activeIndex = [0];
        // @TODO change types for listeners to all files
        this.listeners = [];
        // @TODO change types for subscriptions to all files
        this.subscriptions = [];
        this.styleClass = 'box-group';
        this.collapseStart = new EventEmitter();
        this.collapseDone = new EventEmitter();
    }
    set _activeIndex(value) {
        this.activeIndex = value instanceof Array ? value : [value];
    }
    /**
     * [headerMouseLeave description]
     * @method headerMouseLeave
     * @param accordion [description]
     */
    static headerMouseLeave(accordion) {
        accordion.headerStyleColor = accordion.headerColor;
    }
    /**
     * [headerMouseEnter description]
     * @method headerMouseEnter
     * @param accordion [description]
     */
    static headerMouseEnter(accordion) {
        if (accordion.headerColorHover) {
            accordion.headerStyleColor = accordion.headerColorHover;
        }
    }
    /**
     * @method ngAfterViewInit
     */
    ngAfterContentInit() {
        this.setAccordionsIndex();
        this.updateAccordionIsCollapsed();
        this.subscriptions.push(this.accordionComponents.changes.subscribe(() => {
            this.setAccordionsIndex();
        }));
    }
    /**
     * @method ngAfterViewInit
     */
    ngAfterViewInit() {
        this.setAccordionsToggle();
        this.subscriptions.push(this.accordionToggleDirectives.changes.subscribe(() => {
            this.setAccordionsToggle();
        }));
    }
    /**
     * [ngOnChanges description]
     * @method ngOnChanges
     * @param changes [description]
     * @return [description]
     */
    ngOnChanges(changes) {
        if (changes._activeIndex.firstChange === false) {
            this.updateAccordionIsCollapsed();
        }
    }
    /**
     * @method ngOnDestroy
     */
    ngOnDestroy() {
        removeListeners(this.listeners);
        removeSubscriptions(this.subscriptions);
    }
    /**
     * [toggleAccordion description]
     * @method toggleAccordion
     * @param event       [description]
     * @param toggleIndex [description]
     */
    toggleAccordion(event, toggleIndex) {
        event.preventDefault();
        const indexOf = this.activeIndex.indexOf(toggleIndex);
        if (indexOf === -1) {
            if (this.isMultiple) {
                this.activeIndex.push(toggleIndex);
            }
            else {
                this.activeIndex = [toggleIndex];
            }
        }
        else {
            if (this.isMultiple) {
                this.activeIndex.splice(indexOf, 1);
            }
            else {
                this.activeIndex = [];
            }
        }
        this.updateAccordionIsCollapsed();
    }
    /**
     * [collapseStart description]
     * @method collapseStart
     * @param event [description]
     * @param accordion [description]
     */
    onCollapseStart(event, accordion) {
        accordion.isCollapsing = true;
        this.collapseStart.emit({ animationEvent: event, index: accordion.index });
    }
    /**
     * [collapseDone description]
     * @method collapseDone
     * @param event [description]
     * @param accordion [description]
     */
    onCollapseDone(event, accordion) {
        accordion.isCollapsing = false;
        this.collapseDone.emit({ animationEvent: event, index: accordion.index });
    }
    /**
     * [setAccordionsIndex description]
     * @method setAccordionsIndex
     */
    setAccordionsIndex() {
        this.accordionComponents.forEach((accordion, index) => {
            accordion.index = index;
        });
    }
    /**
     * [setAccordionsToggle description]
     * @method setAccordionsToggle
     */
    setAccordionsToggle() {
        this.listeners = removeListeners(this.listeners);
        this.ngZone.runOutsideAngular(() => {
            this.accordionToggleDirectives.forEach((accordionToggle) => {
                this.listeners.push(this.renderer2.listen(accordionToggle.elementRef.nativeElement, 'click', (event) => {
                    this.toggleAccordion(event, accordionToggle.accordionComponent.index);
                    this.changeDetectorRef.detectChanges();
                }));
                this.listeners.push(this.renderer2.listen(accordionToggle.elementRef.nativeElement, 'mouseenter', () => {
                    AccordionGroupComponent_1.headerMouseEnter(accordionToggle.accordionComponent);
                    this.changeDetectorRef.detectChanges();
                }));
                this.listeners.push(this.renderer2.listen(accordionToggle.elementRef.nativeElement, 'mouseleave', () => {
                    AccordionGroupComponent_1.headerMouseLeave(accordionToggle.accordionComponent);
                    this.changeDetectorRef.detectChanges();
                }));
            });
        });
    }
    /**
     * [updateAccordionIsCollapsed description]
     * @method updateAccordionIsCollapsed
     */
    updateAccordionIsCollapsed() {
        this.accordionComponents.forEach((accordion, index) => {
            accordion.isCollapsed = this.activeIndex.indexOf(index) === -1;
        });
    }
};
AccordionGroupComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: Renderer2 }
];
__decorate([
    Input('activeIndex'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], AccordionGroupComponent.prototype, "_activeIndex", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], AccordionGroupComponent.prototype, "isMultiple", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AccordionGroupComponent.prototype, "styleClass", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], AccordionGroupComponent.prototype, "collapseStart", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], AccordionGroupComponent.prototype, "collapseDone", void 0);
__decorate([
    ContentChildren(AccordionComponent),
    __metadata("design:type", QueryList)
], AccordionGroupComponent.prototype, "accordionComponents", void 0);
__decorate([
    ViewChildren(AccordionToggleDirective),
    __metadata("design:type", QueryList)
], AccordionGroupComponent.prototype, "accordionToggleDirectives", void 0);
AccordionGroupComponent = AccordionGroupComponent_1 = __decorate([
    Component({
        selector: 'mk-accordion-group',
        template: "<div [ngClass]=\"styleClass\">\n  <div *ngFor=\"let accordion of accordionComponents\" class=\"panel box\" [mkColor]=\"accordion.borderColor\" mkColorProperty=\"border-top-color\" mkColorPrefix=\"box\">\n    <div [ngClass]=\"accordion.headerStyleClass\" [class.no-border]=\"accordion.isCollapsed && !accordion.isCollapsing\">\n      <h4 class=\"box-title\">\n        <a [mkAccordionToggle]=\"accordion\" href=\"#\" [mkFontColor]=\"accordion.headerStyleColor\" [class.collapsed]=\"accordion.isCollapsed\">\n          {{accordion.header}}\n          <ng-template *ngIf=\"!accordion.header\" [ngTemplateOutlet]=\"accordion.accordionHeaderComponent?.templateRef\"></ng-template>\n        </a>\n      </h4>\n    </div>\n    <div class=\"panel-collapse\" [mkCollapseAnimation]=\"accordion.isCollapsed\" (mkCollapseAnimation.start)=\"onCollapseStart($event, accordion)\" (mkCollapseAnimation.done)=\"onCollapseDone($event, accordion)\">\n      <div [ngClass]=\"accordion.contentStyleClass\" [mkFontColor]=\"accordion.contentColor\">\n        <ng-template [ngTemplateOutlet]=\"accordion.contentTemplateRef\"></ng-template>\n      </div>\n    </div>\n  </div>\n</div>\n"
    }),
    __metadata("design:paramtypes", [ChangeDetectorRef,
        NgZone,
        Renderer2])
], AccordionGroupComponent);
export { AccordionGroupComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWNjb3JkaW9uLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItYWRtaW4tbHRlLyIsInNvdXJjZXMiOlsibGliL2FjY29yZGlvbi9hY2NvcmRpb24uY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsT0FBTyxFQUNMLGdCQUFnQixFQUNoQixhQUFhLEVBQ2IsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxZQUFZLEVBQ1osZUFBZSxFQUNmLFlBQVksRUFDWixLQUFLLEVBQ0wsTUFBTSxFQUNOLFNBQVMsRUFDVCxTQUFTLEVBQ1QsTUFBTSxFQUNOLE1BQU0sRUFDTixTQUFTLEVBQ1QsU0FBUyxFQUNULGFBQWEsRUFDYixXQUFXLEVBQ1gsU0FBUyxFQUNULFlBQVksRUFDYixNQUFNLGVBQWUsQ0FBQztBQUl2QixPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUVqRSxPQUFPLEVBQUUsZUFBZSxFQUFFLG1CQUFtQixFQUFFLE1BQU0sWUFBWSxDQUFDO0FBR2xFOztHQUVHO0FBS0gsSUFBYSx3QkFBd0IsR0FBckMsTUFBYSx3QkFBd0I7Q0FFcEMsQ0FBQTtBQUQ2QztJQUEzQyxTQUFTLENBQUMsYUFBYSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFDOzhCQUFxQixXQUFXOzZEQUFNO0FBRHRFLHdCQUF3QjtJQUpwQyxTQUFTLENBQUM7UUFDVCxRQUFRLEVBQUUscUJBQXFCO1FBQy9CLFFBQVEsRUFBRSxtRUFBbUU7S0FDOUUsQ0FBQztHQUNXLHdCQUF3QixDQUVwQztTQUZZLHdCQUF3QjtBQUtyQzs7R0FFRztBQUtILElBQWEseUJBQXlCLEdBQXRDLE1BQWEseUJBQXlCO0NBRXJDLENBQUE7QUFENkM7SUFBM0MsU0FBUyxDQUFDLGFBQWEsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBQzs4QkFBcUIsV0FBVzs4REFBTTtBQUR0RSx5QkFBeUI7SUFKckMsU0FBUyxD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dCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIEFmdGVyVmlld0luaXQsXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZCxcbiAgQ29udGVudENoaWxkcmVuLFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBOZ1pvbmUsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIE91dHB1dCxcbiAgUXVlcnlMaXN0LFxuICBSZW5kZXJlcjIsXG4gIFNpbXBsZUNoYW5nZXMsXG4gIFRlbXBsYXRlUmVmLFxuICBWaWV3Q2hpbGQsXG4gIFZpZXdDaGlsZHJlblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQW5pbWF0aW9uRXZlbnQgfSBmcm9tICcuLi9hbmltYXRpb25zL2FuaW1hdGlvbnMuaW50ZXJmYWNlJztcblxuaW1wb3J0IHsgQWNjb3JkaW9uVG9nZ2xlRGlyZWN0aXZlIH0gZnJvbSAnLi9hY2NvcmRpb24uZGlyZWN0aXZlJztcblxuaW1wb3J0IHsgcmVtb3ZlTGlzdGVuZXJzLCByZW1vdmVTdWJzY3JpcHRpb25zIH0gZnJvbSAnLi4vaGVscGVycyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuLypcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ21rLWFjY29yZGlvbi1oZWFkZXInLFxuICB0ZW1wbGF0ZTogJzxuZy10ZW1wbGF0ZSAjdGVtcGxhdGVSZWY+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PjwvbmctdGVtcGxhdGU+J1xufSlcbmV4cG9ydCBjbGFzcyBBY2NvcmRpb25IZWFkZXJDb21wb25lbnQge1xuICBAVmlld0NoaWxkKCd0ZW1wbGF0ZVJlZicsIHsgc3RhdGljOiB0cnVlIH0pIHB1YmxpYyB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55Pjtcbn1cblxuXG4vKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbWstYWNjb3JkaW9uLWNvbnRlbnQnLFxuICB0ZW1wbGF0ZTogJzxuZy10ZW1wbGF0ZSAjdGVtcGxhdGVSZWY+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PjwvbmctdGVtcGxhdGU+J1xufSlcbmV4cG9ydCBjbGFzcyBBY2NvcmRpb25Db250ZW50Q29tcG9uZW50IHtcbiAgQFZpZXdDaGlsZCgndGVtcGxhdGVSZWYnLCB7IHN0YXRpYzogdHJ1ZSB9KSBwdWJsaWMgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT47XG59XG5cblxuLypcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ21rLWFjY29yZGlvbicsXG4gIHRlbXBsYXRlOiAnPG5nLXRlbXBsYXRlICN0ZW1wbGF0ZVJlZj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9uZy10ZW1wbGF0ZT4nXG59KVxuZXhwb3J0IGNsYXNzIEFjY29yZGlvbkNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIHB1YmxpYyBjb250ZW50VGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPEFjY29yZGlvbkNvbnRlbnRDb21wb25lbnQ+O1xuICBwdWJsaWMgaGVhZGVyU3R5bGVDb2xvcjogc3RyaW5nO1xuICBwdWJsaWMgaXNDb2xsYXBzaW5nOiBib29sZWFuO1xuICBwdWJsaWMgaXNDb2xsYXBzZWQ6IGJvb2xlYW47XG4gIHB1YmxpYyBpbmRleDogbnVtYmVyO1xuXG4gIEBJbnB1dCgpIHB1YmxpYyBib3JkZXJDb2xvcjogc3RyaW5nO1xuICBASW5wdXQoKSBwdWJsaWMgY29udGVudENvbG9yOiBzdHJpbmc7XG4gIEBJbnB1dCgpIHB1YmxpYyBjb250ZW50U3R5bGVDbGFzcyA9ICdib3gtYm9keSc7XG4gIEBJbnB1dCgpIHB1YmxpYyBoZWFkZXI6IHN0cmluZztcbiAgQElucHV0KCkgcHVibGljIGhlYWRlckNvbG9yOiBzdHJpbmc7XG4gIEBJbnB1dCgpIHB1YmxpYyBoZWFkZXJDb2xvckhvdmVyOiBzdHJpbmc7XG4gIEBJbnB1dCgpIHB1YmxpYyBoZWFkZXJTdHlsZUNsYXNzID0gJ2JveC1oZWFkZXIgd2l0aC1ib3JkZXInO1xuXG4gIEBDb250ZW50Q2hpbGQoQWNjb3JkaW9uSGVhZGVyQ29tcG9uZW50LCAvKiBUT0RPOiBhZGQgc3RhdGljIGZsYWcgKi8ge30pIHB1YmxpYyBhY2NvcmRpb25IZWFkZXJDb21wb25lbnQ6IEFjY29yZGlvbkhlYWRlckNvbXBvbmVudDtcbiAgQENvbnRlbnRDaGlsZChBY2NvcmRpb25Db250ZW50Q29tcG9uZW50LCAvKiBUT0RPOiBhZGQgc3RhdGljIGZsYWcgKi8ge30pIHB1YmxpYyBhY2NvcmRpb25Db250ZW50Q29tcG9uZW50OiBBY2NvcmRpb25Db250ZW50Q29tcG9uZW50O1xuXG4gIEBWaWV3Q2hpbGQoJ3RlbXBsYXRlUmVmJywgeyBzdGF0aWM6IHRydWUgfSkgcHVibGljIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIG5nT25Jbml0XG4gICAqL1xuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLmhlYWRlclN0eWxlQ29sb3IgPSB0aGlzLmhlYWRlckNvbG9yO1xuXG4gICAgaWYgKCF0aGlzLmhlYWRlciAmJiAhdGhpcy5hY2NvcmRpb25IZWFkZXJDb21wb25lbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXR0cmlidXRlIFwiaGVhZGVyXCIgT1IgQ29tcG9uZW50IFwibWstK2FjY29yZGlvbi1oZWFkZXJcIiBpcyByZXF1aXJlZCBmb3IgY29tcG9uZW50IFwibWstK2FjY29yZGlvblwiJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWNjb3JkaW9uQ29udGVudENvbXBvbmVudCkge1xuICAgICAgdGhpcy5jb250ZW50VGVtcGxhdGVSZWYgPSB0aGlzLmFjY29yZGlvbkNvbnRlbnRDb21wb25lbnQudGVtcGxhdGVSZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29udGVudFRlbXBsYXRlUmVmID0gdGhpcy50ZW1wbGF0ZVJlZjtcbiAgICB9XG4gIH1cbn1cblxuXG4vKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbWstYWNjb3JkaW9uLWdyb3VwJyxcbiAgdGVtcGxhdGVVcmw6ICcuL2FjY29yZGlvbi5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgQWNjb3JkaW9uR3JvdXBDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBBZnRlclZpZXdJbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgYWN0aXZlSW5kZXg6IGFueSA9IFswXTtcbiAgLy8gQFRPRE8gY2hhbmdlIHR5cGVzIGZvciBsaXN0ZW5lcnMgdG8gYWxsIGZpbGVzXG4gIHByaXZhdGUgbGlzdGVuZXJzOiBBcnJheTwoKSA9PiB2b2lkPiA9IFtdO1xuICAvLyBAVE9ETyBjaGFuZ2UgdHlwZXMgZm9yIHN1YnNjcmlwdGlvbnMgdG8gYWxsIGZpbGVzXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogQXJyYXk8U3Vic2NyaXB0aW9uPiA9IFtdO1xuXG5cbiAgQElucHV0KCdhY3RpdmVJbmRleCcpIHNldCBfYWN0aXZlSW5kZXgodmFsdWUpIHtcbiAgICB0aGlzLmFjdGl2ZUluZGV4ID0gdmFsdWUgaW5zdGFuY2VvZiBBcnJheSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgfVxuICBASW5wdXQoKSBwdWJsaWMgaXNNdWx0aXBsZTogYm9vbGVhbjtcbiAgQElucHV0KCkgcHVibGljIHN0eWxlQ2xhc3MgPSAnYm94LWdyb3VwJztcblxuICBAT3V0cHV0KCkgcHVibGljIGNvbGxhcHNlU3RhcnQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIEBPdXRwdXQoKSBwdWJsaWMgY29sbGFwc2VEb25lID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIEBDb250ZW50Q2hpbGRyZW4oQWNjb3JkaW9uQ29tcG9uZW50KSBwdWJsaWMgYWNjb3JkaW9uQ29tcG9uZW50czogUXVlcnlMaXN0PEFjY29yZGlvbkNvbXBvbmVudD47XG5cbiAgQFZpZXdDaGlsZHJlbihBY2NvcmRpb25Ub2dnbGVEaXJlY3RpdmUpIHByaXZhdGUgYWNjb3JkaW9uVG9nZ2xlRGlyZWN0aXZlczogUXVlcnlMaXN0PEFjY29yZGlvblRvZ2dsZURpcmVjdGl2ZT47XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgY29uc3RydWN0b3JcbiAgICogQHBhcmFtIGNoYW5nZURldGVjdG9yUmVmIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtIG5nWm9uZSAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtIHJlbmRlcmVyMiAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLFxuICAgIHByaXZhdGUgbmdab25lOiBOZ1pvbmUsXG4gICAgcHJpdmF0ZSByZW5kZXJlcjI6IFJlbmRlcmVyMlxuICApIHt9XG5cbiAgLyoqXG4gICAqIFtoZWFkZXJNb3VzZUxlYXZlIGRlc2NyaXB0aW9uXVxuICAgKiBAbWV0aG9kIGhlYWRlck1vdXNlTGVhdmVcbiAgICogQHBhcmFtIGFjY29yZGlvbiBbZGVzY3JpcHRpb25dXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGhlYWRlck1vdXNlTGVhdmUoYWNjb3JkaW9uOiBBY2NvcmRpb25Db21wb25lbnQpOiB2b2lkIHtcbiAgICBhY2NvcmRpb24uaGVhZGVyU3R5bGVDb2xvciA9IGFjY29yZGlvbi5oZWFkZXJDb2xvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBbaGVhZGVyTW91c2VFbnRlciBkZXNjcmlwdGlvbl1cbiAgICogQG1ldGhvZCBoZWFkZXJNb3VzZUVudGVyXG4gICAqIEBwYXJhbSBhY2NvcmRpb24gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBoZWFkZXJNb3VzZUVudGVyKGFjY29yZGlvbjogQWNjb3JkaW9uQ29tcG9uZW50KTogdm9pZCB7XG4gICAgaWYgKGFjY29yZGlvbi5oZWFkZXJDb2xvckhvdmVyKSB7XG4gICAgICBhY2NvcmRpb24uaGVhZGVyU3R5bGVDb2xvciA9IGFjY29yZGlvbi5oZWFkZXJDb2xvckhvdmVyO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIG5nQWZ0ZXJWaWV3SW5pdFxuICAgKi9cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIHRoaXMuc2V0QWNjb3JkaW9uc0luZGV4KCk7XG4gICAgdGhpcy51cGRhdGVBY2NvcmRpb25Jc0NvbGxhcHNlZCgpO1xuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2godGhpcy5hY2NvcmRpb25Db21wb25lbnRzLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuc2V0QWNjb3JkaW9uc0luZGV4KCk7XG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgbmdBZnRlclZpZXdJbml0XG4gICAqL1xuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5zZXRBY2NvcmRpb25zVG9nZ2xlKCk7XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaCh0aGlzLmFjY29yZGlvblRvZ2dsZURpcmVjdGl2ZXMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5zZXRBY2NvcmRpb25zVG9nZ2xlKCk7XG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFtuZ09uQ2hhbmdlcyBkZXNjcmlwdGlvbl1cbiAgICogQG1ldGhvZCBuZ09uQ2hhbmdlc1xuICAgKiBAcGFyYW0gY2hhbmdlcyBbZGVzY3JpcHRpb25dXG4gICAqIEByZXR1cm4gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIGlmIChjaGFuZ2VzLl9hY3RpdmVJbmRleC5maXJzdENoYW5nZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMudXBkYXRlQWNjb3JkaW9uSXNDb2xsYXBzZWQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBuZ09uRGVzdHJveVxuICAgKi9cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgcmVtb3ZlTGlzdGVuZXJzKHRoaXMubGlzdGVuZXJzKTtcbiAgICByZW1vdmVTdWJzY3JpcHRpb25zKHRoaXMuc3Vic2NyaXB0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogW3RvZ2dsZUFjY29yZGlvbiBkZXNjcmlwdGlvbl1cbiAgICogQG1ldGhvZCB0b2dnbGVBY2NvcmRpb25cbiAgICogQHBhcmFtIGV2ZW50ICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtIHRvZ2dsZUluZGV4IFtkZXNjcmlwdGlvbl1cbiAgICovXG4gIHB1YmxpYyB0b2dnbGVBY2NvcmRpb24oZXZlbnQ6IEV2ZW50LCB0b2dnbGVJbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IGluZGV4T2YgPSB0aGlzLmFjdGl2ZUluZGV4LmluZGV4T2YodG9nZ2xlSW5kZXgpO1xuICAgIGlmIChpbmRleE9mID09PSAtMSkge1xuICAgICAgaWYgKHRoaXMuaXNNdWx0aXBsZSkge1xuICAgICAgICB0aGlzLmFjdGl2ZUluZGV4LnB1c2godG9nZ2xlSW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hY3RpdmVJbmRleCA9IFt0b2dnbGVJbmRleF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmlzTXVsdGlwbGUpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVJbmRleC5zcGxpY2UoaW5kZXhPZiwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFjdGl2ZUluZGV4ID0gW107XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudXBkYXRlQWNjb3JkaW9uSXNDb2xsYXBzZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBbY29sbGFwc2VTdGFydCBkZXNjcmlwdGlvbl1cbiAgICogQG1ldGhvZCBjb2xsYXBzZVN0YXJ0XG4gICAqIEBwYXJhbSBldmVudCBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSBhY2NvcmRpb24gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgcHVibGljIG9uQ29sbGFwc2VTdGFydChldmVudDogQW5pbWF0aW9uRXZlbnQsIGFjY29yZGlvbjogQWNjb3JkaW9uQ29tcG9uZW50KTogdm9pZCB7XG4gICAgYWNjb3JkaW9uLmlzQ29sbGFwc2luZyA9IHRydWU7XG4gICAgdGhpcy5jb2xsYXBzZVN0YXJ0LmVtaXQoe2FuaW1hdGlvbkV2ZW50OiBldmVudCwgaW5kZXg6IGFjY29yZGlvbi5pbmRleH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFtjb2xsYXBzZURvbmUgZGVzY3JpcHRpb25dXG4gICAqIEBtZXRob2QgY29sbGFwc2VEb25lXG4gICAqIEBwYXJhbSBldmVudCBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSBhY2NvcmRpb24gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgcHVibGljIG9uQ29sbGFwc2VEb25lKGV2ZW50OiBBbmltYXRpb25FdmVudCwgYWNjb3JkaW9uOiBBY2NvcmRpb25Db21wb25lbnQpOiB2b2lkIHtcbiAgICBhY2NvcmRpb24uaXNDb2xsYXBzaW5nID0gZmFsc2U7XG4gICAgdGhpcy5jb2xsYXBzZURvbmUuZW1pdCh7YW5pbWF0aW9uRXZlbnQ6IGV2ZW50LCBpbmRleDogYWNjb3JkaW9uLmluZGV4fSk7XG4gIH1cblxuICAvKipcbiAgICogW3NldEFjY29yZGlvbnNJbmRleCBkZXNjcmlwdGlvbl1cbiAgICogQG1ldGhvZCBzZXRBY2NvcmRpb25zSW5kZXhcbiAgICovXG4gIHByaXZhdGUgc2V0QWNjb3JkaW9uc0luZGV4KCk6IHZvaWQge1xuICAgIHRoaXMuYWNjb3JkaW9uQ29tcG9uZW50cy5mb3JFYWNoKChhY2NvcmRpb246IEFjY29yZGlvbkNvbXBvbmVudCwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgYWNjb3JkaW9uLmluZGV4ID0gaW5kZXg7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogW3NldEFjY29yZGlvbnNUb2dnbGUgZGVzY3JpcHRpb25dXG4gICAqIEBtZXRob2Qgc2V0QWNjb3JkaW9uc1RvZ2dsZVxuICAgKi9cbiAgcHJpdmF0ZSBzZXRBY2NvcmRpb25zVG9nZ2xlKCk6IHZvaWQge1xuICAgIHRoaXMubGlzdGVuZXJzID0gcmVtb3ZlTGlzdGVuZXJzKHRoaXMubGlzdGVuZXJzKTtcblxuICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgIHRoaXMuYWNjb3JkaW9uVG9nZ2xlRGlyZWN0aXZlcy5mb3JFYWNoKChhY2NvcmRpb25Ub2dnbGU6IEFjY29yZGlvblRvZ2dsZURpcmVjdGl2ZSkgPT4ge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5wdXNoKHRoaXMucmVuZGVyZXIyLmxpc3RlbihhY2NvcmRpb25Ub2dnbGUuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICB0aGlzLnRvZ2dsZUFjY29yZGlvbihldmVudCwgYWNjb3JkaW9uVG9nZ2xlLmFjY29yZGlvbkNvbXBvbmVudC5pbmRleCk7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaCh0aGlzLnJlbmRlcmVyMi5saXN0ZW4oYWNjb3JkaW9uVG9nZ2xlLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ21vdXNlZW50ZXInLCAoKSA9PiB7XG4gICAgICAgICAgQWNjb3JkaW9uR3JvdXBDb21wb25lbnQuaGVhZGVyTW91c2VFbnRlcihhY2NvcmRpb25Ub2dnbGUuYWNjb3JkaW9uQ29tcG9uZW50KTtcbiAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5wdXNoKHRoaXMucmVuZGVyZXIyLmxpc3RlbihhY2NvcmRpb25Ub2dnbGUuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnbW91c2VsZWF2ZScsICgpID0+IHtcbiAgICAgICAgICBBY2NvcmRpb25Hcm91cENvbXBvbmVudC5oZWFkZXJNb3VzZUxlYXZlKGFjY29yZGlvblRvZ2dsZS5hY2NvcmRpb25Db21wb25lbnQpO1xuICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBbdXBkYXRlQWNjb3JkaW9uSXNDb2xsYXBzZWQgZGVzY3JpcHRpb25dXG4gICAqIEBtZXRob2QgdXBkYXRlQWNjb3JkaW9uSXNDb2xsYXBzZWRcbiAgICovXG4gIHByaXZhdGUgdXBkYXRlQWNjb3JkaW9uSXNDb2xsYXBzZWQoKTogdm9pZCB7XG4gICAgdGhpcy5hY2NvcmRpb25Db21wb25lbnRzLmZvckVhY2goKGFjY29yZGlvbjogQWNjb3JkaW9uQ29tcG9uZW50LCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICBhY2NvcmRpb24uaXNDb2xsYXBzZWQgPSB0aGlzLmFjdGl2ZUluZGV4LmluZGV4T2YoaW5kZXgpID09PSAtMTtcbiAgICB9KTtcbiAgfVxufVxuIl19