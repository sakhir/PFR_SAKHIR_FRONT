import { __decorate, __metadata, __param } from 'tslib';
import { Injectable, ChangeDetectorRef, Input, Component, NgModule, ElementRef, ViewChild, ChangeDetectionStrategy, TemplateRef, ContentChild, NgZone, Renderer2, EventEmitter, Output, Directive, ViewChildren, QueryList, InjectionToken, Optional, SkipSelf, ContentChildren, ViewContainerRef, HostListener } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NavigationEnd, PRIMARY_OUTLET, Router, RouterModule, NavigationStart, ActivationStart } from '@angular/router';
import { BehaviorSubject, Subject } from 'rxjs';
import { Title } from '@angular/platform-browser';
import { pluck, distinctUntilChanged } from 'rxjs/operators';
import { NgControl, FormsModule } from '@angular/forms';

var RoutingService_1;
/*
 *
 */
let RoutingService = RoutingService_1 = class RoutingService {
    /**
     * @method constructor
     * @param router [description]
     */
    constructor(router) {
        this.router = router;
        this.onChange = new BehaviorSubject(undefined);
        this.events = new BehaviorSubject(undefined);
        this.init();
    }
    /**
     * [createUrl description]
     * @method createUrl
     * @param route [description]
     * @return [description]
     */
    static createUrl(route) {
        const url = route.url.map(urlSegment => urlSegment.toString()).join('/');
        return url;
    }
    /**
     * [isChildrenSelfRoute description]
     * @method isChildrenSelfRoute
     * @param route [description]
     * @return [description]
     */
    static isChildrenSelfRoute(route) {
        route.routeConfig.children.forEach(child => {
            if (child.path === '' && (child.component || child.loadChildren)) {
                return true;
            }
        });
        return false;
    }
    /**
     * [createBreadcrumb description]
     * @method createBreadcrumb
     * @param route [description]
     * @param url   [description]
     * @return [description]
     */
    static createBreadcrumb(route, url) {
        let isUrl = true;
        if (route.children.length !== 0 && route.firstChild.routeConfig.path) {
            if (url !== '/' && !route.routeConfig.loadChildren && !route.routeConfig.component && !RoutingService_1.isChildrenSelfRoute(route)) {
                isUrl = false;
            }
        }
        return {
            data: route.data,
            params: route.params,
            url: isUrl ? url : null
        };
    }
    /**
     * [init description]
     * @method init
     */
    init() {
        this.router.events.subscribe(routeEvent => {
            // https://github.com/angular/angular/issues/17473: event not fired anymore on load for routed component.
            if (routeEvent instanceof NavigationEnd) {
                this.events.next(routeEvent);
                let route = this.router.routerState.root.snapshot;
                let tmpUrl = '';
                let url = '';
                let rootRoot = true;
                const paths = [];
                while (route.children.length) {
                    route = route.firstChild;
                    tmpUrl = `/${RoutingService_1.createUrl(route)}`;
                    if (route.outlet !== PRIMARY_OUTLET || (!route.routeConfig.path && !rootRoot)) {
                        continue;
                    }
                    rootRoot = false;
                    if (route.params && route.data) {
                        for (const key in route.params) {
                            if (!key) {
                                continue;
                            }
                            if (route.data.hasOwnProperty('title')) {
                                route.data.title = route.data.title.replace(`:${key}`, route.params[key]);
                                route.data.title = route.data.title.replace(`:${key}`, route.params[key]);
                            }
                            if (route.data.hasOwnProperty('breadcrumbs')) {
                                route.data.breadcrumbs = route.data.breadcrumbs.replace(`:${key}`, route.params[key]);
                            }
                            if (route.data.hasOwnProperty('description')) {
                                route.data.description = route.data.description.replace(`:${key}`, route.params[key]);
                            }
                        }
                    }
                    if (tmpUrl === '/') {
                        paths.push(RoutingService_1.createBreadcrumb(route, tmpUrl));
                    }
                    else {
                        url += tmpUrl;
                        paths.push(RoutingService_1.createBreadcrumb(route, url));
                    }
                }
                this.onChange.next(paths);
            }
        });
    }
};
RoutingService.ctorParameters = () => [
    { type: Router }
];
RoutingService = RoutingService_1 = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [Router])
], RoutingService);

/*
 *
 */
let BreadcrumbsComponent = class BreadcrumbsComponent {
    /**
     * @method constructor
     * @param routingService [description]
     * @param changeDetectorRef [description]
     */
    constructor(routingService, changeDetectorRef) {
        this.routingService = routingService;
        this.changeDetectorRef = changeDetectorRef;
        this.homeIcon = 'fa fa-home';
    }
    /**
     * @method ngOnInit
     */
    ngOnInit() {
        this.subscription = this.routingService.onChange.subscribe(value => {
            this.breadcrumbs = value;
        });
    }
    /**
     * @method ngOnDestroy
     */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
};
BreadcrumbsComponent.ctorParameters = () => [
    { type: RoutingService },
    { type: ChangeDetectorRef }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], BreadcrumbsComponent.prototype, "homeIcon", void 0);
BreadcrumbsComponent = __decorate([
    Component({
        selector: 'mk-breadcrumbs',
        template: "\n<ol class=\"breadcrumb\">\n  <li *ngFor=\"let breadcrumb of breadcrumbs; let first = first; let last = last\" [class.active]=\"last || !breadcrumb.url\">\n    <a *ngIf=\"breadcrumb.url && !last; else noLink\" [routerLink]=\"breadcrumb.url\">\n      <i *ngIf=\"first\" ngClass=\"{{homeIcon}}\"></i>\n      <ng-template [ngIf]=\"breadcrumb.data.breadcrumbs\">{{breadcrumb.data.breadcrumbs}}</ng-template>\n      <ng-template [ngIf]=\"!breadcrumb.data.breadcrumbs\">{{breadcrumb.data.title}}</ng-template>\n    </a>\n    <ng-template #noLink>\n      <i *ngIf=\"first\" ngClass=\"{{homeIcon}}\"></i>\n      <ng-template [ngIf]=\"breadcrumb.data.breadcrumbs\">{{breadcrumb.data.breadcrumbs}}</ng-template>\n      <ng-template [ngIf]=\"!breadcrumb.data.breadcrumbs\">{{breadcrumb.data.title}}</ng-template>\n    </ng-template>\n  </li>\n</ol>\n",
        styles: [".breadcrumb{float:right;background:0 0;margin-top:0;margin-bottom:0;font-size:12px;padding:7px 5px;position:absolute;top:15px;right:10px;border-radius:2px}.breadcrumb>li>a{color:#444;text-decoration:none;display:inline-block}.breadcrumb>li .fa,.breadcrumb>li .glyphicon,.breadcrumb>li .ion{margin-right:5px}"]
    }),
    __metadata("design:paramtypes", [RoutingService,
        ChangeDetectorRef])
], BreadcrumbsComponent);

let BreadcrumbsModule = class BreadcrumbsModule {
};
BreadcrumbsModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        exports: [BreadcrumbsComponent],
        declarations: [BreadcrumbsComponent]
    })
], BreadcrumbsModule);

/*
 *
 */
class LayoutStore {
    /**
     * @method constructor
     * @param layoutConfig [description]
     */
    constructor(layoutConfig) {
        this.initialLayoutState = {
            isSidebarLeftCollapsed: false,
            isSidebarLeftExpandOnOver: false,
            isSidebarLeftMouseOver: false,
            isSidebarLeftMini: true,
            sidebarRightSkin: 'dark',
            isSidebarRightCollapsed: true,
            isSidebarRightOverContent: true,
            layout: 'normal',
            sidebarLeftMenu: [],
            sidebarLeftMenuActiveUrl: '',
            skin: 'blue'
        };
        if (layoutConfig) {
            this.initialLayoutState = Object.assign(this.initialLayoutState, layoutConfig);
        }
        this.state = new BehaviorSubject(this.initialLayoutState);
        this.layoutState = this.state.asObservable();
    }
    /**
     * [windowInnerHeight description]
     * @method windowInnerHeight
     * @return [description]
     */
    get windowInnerHeight() {
        return this.layoutState.pipe(pluck('windowInnerHeight'), distinctUntilChanged());
    }
    /**
     * [windowInnerWidth description]
     * @method windowInnerWidth
     * @return [description]
     */
    get windowInnerWidth() {
        return this.layoutState.pipe(pluck('windowInnerWidth'), distinctUntilChanged());
    }
    /**
     * [isSidebarLeftCollapsed description]
     * @return [description]
     */
    get isSidebarLeftCollapsed() {
        return this.layoutState.pipe(pluck('isSidebarLeftCollapsed'), distinctUntilChanged());
    }
    /**
     * [isSidebarLeftExpandOnOver description]
     * @method isSidebarLeftExpandOnOver
     * @return [description]
     */
    get isSidebarLeftExpandOnOver() {
        return this.layoutState.pipe(pluck('isSidebarLeftExpandOnOver'), distinctUntilChanged());
    }
    /**
     * [isSidebarLeftMouseOver description]
     * @method isSidebarLeftMouseOver
     * @return [description]
     */
    get isSidebarLeftMouseOver() {
        return this.layoutState.pipe(pluck('isSidebarLeftMouseOver'), distinctUntilChanged());
    }
    /**
     * [isSidebarLeftMini description]
     * @method isSidebarLeftMini
     * @return [description]
     */
    get isSidebarLeftMini() {
        return this.layoutState.pipe(pluck('isSidebarLeftMini'), distinctUntilChanged());
    }
    /**
     * [sidebarRightSkin description]
     * @method sidebarRightSkin
     * @return [description]
     */
    get sidebarRightSkin() {
        return this.layoutState.pipe(pluck('sidebarRightSkin'), distinctUntilChanged());
    }
    /**
     * [isSidebarRightCollapsed description]
     * @return [description]
     */
    get isSidebarRightCollapsed() {
        return this.layoutState.pipe(pluck('isSidebarRightCollapsed'), distinctUntilChanged());
    }
    /**
     * [isSidebarRightOverContent description]
     * @method isSidebarRightOverContent
     * @return [description]
     */
    get isSidebarRightOverContent() {
        return this.layoutState.pipe(pluck('isSidebarRightOverContent'), distinctUntilChanged());
    }
    /**
     * [sidebarLeftMenu description]
     * @method sidebarLeftMenu
     * @return [description]
     */
    get sidebarLeftMenu() {
        return this.layoutState.pipe(pluck('sidebarLeftMenu'), distinctUntilChanged());
    }
    /**
     * [sidebarLeftMenuActiveUrl description]
     * @method sidebarLeftMenuActiveUrl
     * @return [description]
     */
    get sidebarLeftMenuActiveUrl() {
        return this.layoutState.pipe(pluck('sidebarLeftMenuActiveUrl'), distinctUntilChanged());
    }
    /**
     * [sidebarLeftElementHeight description]
     * @method sidebarLeftElementHeight
     * @return [description]
     */
    get sidebarLeftElementHeight() {
        return this.layoutState.pipe(pluck('sidebarLeftElementHeight'), distinctUntilChanged());
    }
    /**
     * [layoutType description]
     * @method layoutType
     * @return [description]
     */
    get layout() {
        return this.layoutState.pipe(pluck('layout'), distinctUntilChanged());
    }
    /**
     * [skin description]
     * @method skin
     * @return [description]
     */
    get skin() {
        return this.layoutState.pipe(pluck('skin'), distinctUntilChanged());
    }
    /**
     * [wrapperClasses description]
     * @method wrapperClasses
     * @return [description]
     */
    get wrapperClasses() {
        return this.layoutState.pipe(pluck('wrapperClasses'), distinctUntilChanged());
    }
    /**
     * [sidebarLeftCollapsed description]
     * @method sidebarLeftCollapsed
     * @param value [description]
     */
    sidebarLeftCollapsed(value) {
        this.state.next(Object.assign(this.state.value, { isSidebarLeftCollapsed: value }));
    }
    /**
     * [sidebarLeftExpandOnOver description]
     * @method sidebarLeftExpandOnOver
     * @param value [description]
     */
    sidebarLeftExpandOnOver(value) {
        this.state.next(Object.assign(this.state.value, { isSidebarLeftExpandOnOver: value }));
    }
    /**
     * [setSidebarLeftElementHeight description]
     * @method setSidebarLeftElementHeight
     * @param value [description]
     */
    setSidebarLeftElementHeight(value) {
        this.state.next(Object.assign(this.state.value, { sidebarLeftElementHeight: value }));
    }
    /**
     * [setSidebarRightSkin description]
     * @method setSidebarRightSkin
     * @param value [description]
     */
    setSidebarRightSkin(value) {
        this.state.next(Object.assign(this.state.value, { sidebarRightSkin: value }));
    }
    /**
     * [sidebarLeftMouseOver description]
     * @method sidebarLeftMouseOver
     * @param value [description]
     */
    sidebarLeftMouseOver(value) {
        this.state.next(Object.assign(this.state.value, { isSidebarLeftMouseOver: value }));
    }
    /**
     * [sidebarLeftMini description]
     * @method sidebarLeftMini
     * @param value [description]
     */
    sidebarLeftMini(value) {
        this.state.next(Object.assign(this.state.value, { isSidebarLeftMini: value }));
    }
    /**
     * [sidebarRightCollapsed description]
     * @method sidebarRightCollapsed
     * @param value [description]
     */
    sidebarRightCollapsed(value) {
        this.state.next(Object.assign(this.state.value, { isSidebarRightCollapsed: value }));
    }
    /**
     * [sidebarRightOverContent description]
     * @method sidebarRightOverContent
     * @param value [description]
     */
    sidebarRightOverContent(value) {
        this.state.next(Object.assign(this.state.value, { isSidebarRightOverContent: value }));
    }
    /**
     * [setSidebarLeftMenu description]
     * @method setSidebarLeftMenu
     * @param value [description]
     */
    setSidebarLeftMenu(value) {
        this.state.next(Object.assign(this.state.value, { sidebarLeftMenu: value }));
    }
    /**
     * [setSidebarLeftMenuActiveUrl description]
     * @method setSidebarLeftMenuActiveUrl
     * @param value [description]
     */
    setSidebarLeftMenuActiveUrl(value) {
        this.state.next(Object.assign(this.state.value, { sidebarLeftMenuActiveUrl: value }));
    }
    /**
     * [setLayout description]
     * @method setLayout
     * @param value [description]
     */
    setLayout(value) {
        this.state.next(Object.assign(this.state.value, { layout: value }));
    }
    /**
     * [setSkin description]
     * @method setSkin
     * @param value [description]
     */
    setSkin(value) {
        this.state.next(Object.assign(this.state.value, { skin: value }));
    }
    /**
     * [setWrapperClasses description]
     * @method setWrapperClasses
     * @param value [description]
     */
    setWrapperClasses(value) {
        this.state.next(Object.assign(this.state.value, { wrapperClasses: value }));
    }
    /**
     * [setWindowInnerHeight description]
     * @method setWindowInnerHeight
     * @param value [description]
     */
    setWindowInnerHeight(value) {
        this.state.next(Object.assign(this.state.value, { windowInnerHeight: value }));
    }
    /**
     * [setWindowInnerWidth description]
     * @method setWindowInnerWidth
     * @param value [description]
     */
    setWindowInnerWidth(value) {
        this.state.next(Object.assign(this.state.value, { windowInnerWidth: value }));
    }
}

let SidebarRightService = class SidebarRightService {
    /**
     * [scrollHeight description]
     * @method scrollHeight
     * @return [description]
     */
    get scrollHeight() {
        return this.elementRef ? this.elementRef.nativeElement.scrollHeight : null;
    }
};
SidebarRightService = __decorate([
    Injectable()
], SidebarRightService);

let HeaderService = class HeaderService {
    /**
     * [offsetHeight description]
     * @method offsetHeight
     * @return [description]
     */
    get offsetHeight() {
        return this.elementRef ? this.elementRef.nativeElement.offsetHeight : 0;
    }
};
HeaderService = __decorate([
    Injectable()
], HeaderService);

let FooterService = class FooterService {
    /**
     * [offsetHeight description]
     * @method offsetHeight
     * @return [description]
     */
    get offsetHeight() {
        return this.elementRef ? this.elementRef.nativeElement.offsetHeight : 0;
    }
};
FooterService = __decorate([
    Injectable()
], FooterService);

/**
 * [throttle description]
 * @method throttle
 * @param callback [description]
 * @param delay    [description]
 * @return [description]
 */
function throttle(callback, delay) {
    let timeout = null;
    return (...args) => {
        if (!timeout) {
            timeout = setTimeout(() => {
                callback.call(this, ...args);
                timeout = null;
            }, delay);
        }
    };
}
/**
 * [removeSubscriptions description]
 * @method removeSubscriptions
 */
function removeSubscriptions(subscriptions) {
    if (subscriptions) {
        subscriptions.forEach((subscription) => {
            subscription.unsubscribe();
        });
    }
    return [];
}
/**
 * [removeListeners description]
 * @method removeListeners
 */
function removeListeners(listeners) {
    if (listeners) {
        listeners.forEach((listener) => {
            listener();
        });
    }
    return [];
}

let ContentComponent = class ContentComponent {
    constructor(layoutStore, routingService, titleService, elementRef, changeDetectorRef, sidebarRightService, headerService, footerService, router) {
        this.layoutStore = layoutStore;
        this.routingService = routingService;
        this.titleService = titleService;
        this.elementRef = elementRef;
        this.changeDetectorRef = changeDetectorRef;
        this.sidebarRightService = sidebarRightService;
        this.headerService = headerService;
        this.footerService = footerService;
        this.router = router;
        this.subscriptions = [];
    }
    /**
     * @method ngOnInit
     */
    ngOnInit() {
        this.titleTag = this.titleService.getTitle();
        this.subscriptions.push(this.routingService.onChange.subscribe((value) => {
            if (value && value[value.length - 1] && value[value.length - 1].data) {
                const data = value[value.length - 1].data;
                this.titleService.setTitle(this.getTitle(data.title));
                this.header = data.title;
                this.description = data.description;
            }
            this.changeDetectorRef.markForCheck();
        }));
        this.subscriptions.push(this.router.events.subscribe((routeEvent) => {
            if (routeEvent instanceof NavigationStart) {
                this.navigationEnd = false;
            }
            if (routeEvent instanceof NavigationEnd) {
                this.navigationEnd = true;
                this.setContentMinHeight();
            }
        }));
        this.subscriptions.push(this.layoutStore.sidebarLeftElementHeight.subscribe((value) => {
            this.sidebarLeftHeight = value;
            this.setContentMinHeight();
        }));
        this.subscriptions.push(this.layoutStore.layout.subscribe((value) => {
            this.layout = value;
            this.setContentMinHeight();
        }));
        this.subscriptions.push(this.layoutStore.windowInnerHeight.subscribe((value) => {
            this.windowInnerHeight = value;
            this.setContentMinHeight();
        }));
        this.heightStyle = this.windowInnerHeight;
    }
    /**
     * @method ngOnDestroy
     */
    ngOnDestroy() {
        this.subscriptions = removeSubscriptions(this.subscriptions);
    }
    /**
     * [scrollHeight description]
     * @method scrollHeight
     * @return [description]
     */
    get scrollHeight() {
        return this.contentInnerElement.nativeElement.scrollHeight;
    }
    /**
     * [getTitle description]
     * @method getTitle
     * @param title [description]
     * @return [description]
     */
    getTitle(title) {
        return title ? `${title} - ${this.titleTag}` : this.titleTag;
    }
    /**
     * [setMinHeight description]
     * @method setMinHeight
     */
    setContentMinHeight() {
        if (this.navigationEnd) {
            let heightStyle;
            const headerFooterOffsetHeight = this.headerService.offsetHeight + this.footerService.offsetHeight;
            if (this.layout === 'fixed') {
                heightStyle = this.windowInnerHeight - this.footerService.offsetHeight;
            }
            else {
                const sidebarRight = this.sidebarRightService.scrollHeight ?
                    this.sidebarRightService.scrollHeight - this.headerService.offsetHeight : 0;
                heightStyle = Math.max(this.windowInnerHeight - headerFooterOffsetHeight, this.sidebarLeftHeight - this.headerService.offsetHeight, sidebarRight);
            }
            if (heightStyle && heightStyle !== this.heightStyle) {
                if (this.scrollHeight > heightStyle) {
                    heightStyle = null;
                }
                this.heightStyle = heightStyle;
                this.changeDetectorRef.detectChanges();
            }
        }
    }
};
ContentComponent.ctorParameters = () => [
    { type: LayoutStore },
    { type: RoutingService },
    { type: Title },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: SidebarRightService },
    { type: HeaderService },
    { type: FooterService },
    { type: Router }
];
__decorate([
    ViewChild('contentInnerElement', { static: true }),
    __metadata("design:type", ElementRef)
], ContentComponent.prototype, "contentInnerElement", void 0);
ContentComponent = __decorate([
    Component({
        selector: 'mk-layout-content',
        template: "<div class=\"content-wrapper\" [style.min-height.px]=\"heightStyle\">\n  <div #contentInnerElement class=\"content-inner\">\n    <ng-content select=\"[mk-layout-content-before-header]\"></ng-content>\n    <section *ngIf=\"header || description\" class=\"content-header\">\n      <h1>\n        {{header}}\n        <small *ngIf=\"description\">{{description}}</small>\n      </h1>\n      <mk-breadcrumbs></mk-breadcrumbs>\n    </section>\n    <ng-content select=\"[mk-layout-content-after-header]\"></ng-content>\n    <section class=\"content\">\n      <ng-content></ng-content>\n    </section>\n  </div>\n</div>\n",
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: [":host{display:block}.content-wrapper{position:relative}"]
    }),
    __metadata("design:paramtypes", [LayoutStore,
        RoutingService,
        Title,
        ElementRef,
        ChangeDetectorRef,
        SidebarRightService,
        HeaderService,
        FooterService,
        Router])
], ContentComponent);

let ContentModule = class ContentModule {
};
ContentModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule, BreadcrumbsModule],
        exports: [ContentComponent],
        declarations: [ContentComponent]
    })
], ContentModule);

/**
 * Footer Left
 */
let FooterLeftComponent = class FooterLeftComponent {
};
__decorate([
    ViewChild('templateRef', { static: true }),
    __metadata("design:type", TemplateRef)
], FooterLeftComponent.prototype, "templateRef", void 0);
FooterLeftComponent = __decorate([
    Component({
        selector: 'mk-layout-footer-left',
        template: '<ng-template #templateRef><ng-content></ng-content></ng-template>'
    })
], FooterLeftComponent);
/**
 * Footer Right
 */
let FooterRightComponent = class FooterRightComponent {
};
__decorate([
    ViewChild('templateRef', { static: true }),
    __metadata("design:type", TemplateRef)
], FooterRightComponent.prototype, "templateRef", void 0);
FooterRightComponent = __decorate([
    Component({
        selector: 'mk-layout-footer-right',
        template: '<ng-template #templateRef><ng-content></ng-content></ng-template>'
    })
], FooterRightComponent);
let FooterComponent = class FooterComponent {
    constructor(elementRef, footerService) {
        this.elementRef = elementRef;
        this.footerService = footerService;
    }
    ngOnInit() {
        this.footerService.elementRef = this.elementRef;
    }
};
FooterComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: FooterService }
];
__decorate([
    ContentChild(FooterLeftComponent, /* TODO: add static flag */ {}),
    __metadata("design:type", FooterLeftComponent)
], FooterComponent.prototype, "footerLeftComponent", void 0);
__decorate([
    ContentChild(FooterRightComponent, /* TODO: add static flag */ {}),
    __metadata("design:type", FooterRightComponent)
], FooterComponent.prototype, "footerRightComponent", void 0);
FooterComponent = __decorate([
    Component({
        selector: 'mk-layout-footer',
        template: "<footer class=\"main-footer\">\n  <div class=\"pull-right hidden-xs\">\n    <ng-template [ngTemplateOutlet]=\"footerRightComponent?.templateRef\"></ng-template>\n  </div>\n  <ng-template [ngTemplateOutlet]=\"footerLeftComponent?.templateRef\"></ng-template>\n</footer>\n",
        styles: [":host{display:block}"]
    }),
    __metadata("design:paramtypes", [ElementRef,
        FooterService])
], FooterComponent);

let FooterModule = class FooterModule {
};
FooterModule = __decorate([
    NgModule({
        imports: [CommonModule],
        exports: [FooterComponent, FooterLeftComponent, FooterRightComponent],
        declarations: [FooterComponent, FooterLeftComponent, FooterRightComponent]
    })
], FooterModule);

/**
 * Header Logo
 */
let HeaderLogoComponent = class HeaderLogoComponent {
};
__decorate([
    ViewChild('templateRef', { static: true }),
    __metadata("design:type", TemplateRef)
], HeaderLogoComponent.prototype, "templateRef", void 0);
HeaderLogoComponent = __decorate([
    Component({
        selector: 'mk-layout-header-logo',
        template: '<ng-template #templateRef><ng-content></ng-content></ng-template>'
    })
], HeaderLogoComponent);
/**
 * Header Logo Mini
 */
let HeaderLogoMiniComponent = class HeaderLogoMiniComponent {
};
__decorate([
    ViewChild('templateRef', { static: true }),
    __metadata("design:type", TemplateRef)
], HeaderLogoMiniComponent.prototype, "templateRef", void 0);
HeaderLogoMiniComponent = __decorate([
    Component({
        selector: 'mk-layout-header-logo-mini',
        template: '<ng-template #templateRef><ng-content></ng-content></ng-template>'
    })
], HeaderLogoMiniComponent);
/**
 * Header
 */
let HeaderComponent = class HeaderComponent {
    /**
     * @method constructor
     * @param layoutStore [description]
     * @param ngZone      [description]
     * @param renderer2   [description]
     * @param elementRef   [description]
     * @param headerService   [description]
     */
    constructor(layoutStore, ngZone, renderer2, elementRef, headerService) {
        this.layoutStore = layoutStore;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.elementRef = elementRef;
        this.headerService = headerService;
        this.listeners = [];
        this.subscriptions = [];
        this.isSidebarLeftToggle = true;
        this.isSidebarRightToggle = true;
        this.logoLink = '/';
    }
    /**
     * @method ngAfterViewInit
     */
    ngAfterViewInit() {
        this.headerService.elementRef = this.headerElement;
        if (this.sidebarLeftToggleElement) {
            this.subscriptions.push(this.layoutStore.isSidebarLeftCollapsed.subscribe((value) => {
                this.isSidebarLeftCollapsed = value;
            }));
            this.ngZone.runOutsideAngular(() => {
                this.listeners.push(this.renderer2.listen(this.sidebarLeftToggleElement.nativeElement, 'click', (event) => {
                    event.preventDefault();
                    this.layoutStore.sidebarLeftCollapsed(!this.isSidebarLeftCollapsed);
                }));
            });
        }
        if (this.sidebarRightToggleElement) {
            this.subscriptions.push(this.layoutStore.isSidebarRightCollapsed.subscribe((value) => {
                this.isSidebarRightCollapsed = value;
            }));
            this.ngZone.runOutsideAngular(() => {
                this.listeners.push(this.renderer2.listen(this.sidebarRightToggleElement.nativeElement, 'click', (event) => {
                    event.preventDefault();
                    this.layoutStore.sidebarRightCollapsed(!this.isSidebarRightCollapsed);
                }));
            });
        }
    }
    /**
     * @method ngOnDestroy
     */
    ngOnDestroy() {
        this.listeners = removeListeners(this.listeners);
        this.subscriptions = removeSubscriptions(this.subscriptions);
    }
};
HeaderComponent.ctorParameters = () => [
    { type: LayoutStore },
    { type: NgZone },
    { type: Renderer2 },
    { type: ElementRef },
    { type: HeaderService }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], HeaderComponent.prototype, "isSidebarLeftToggle", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], HeaderComponent.prototype, "sidebarLeftToggleIconClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], HeaderComponent.prototype, "isSidebarRightToggle", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], HeaderComponent.prototype, "sidebarRightToggleIconClasses", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], HeaderComponent.prototype, "logoLink", void 0);
__decorate([
    ContentChild(HeaderLogoComponent, /* TODO: add static flag */ {}),
    __metadata("design:type", HeaderLogoComponent)
], HeaderComponent.prototype, "headerLogoComponent", void 0);
__decorate([
    ContentChild(HeaderLogoMiniComponent, /* TODO: add static flag */ {}),
    __metadata("design:type", HeaderLogoMiniComponent)
], HeaderComponent.prototype, "headerLogoMiniComponent", void 0);
__decorate([
    ViewChild('headerElement', { static: true }),
    __metadata("design:type", ElementRef)
], HeaderComponent.prototype, "headerElement", void 0);
__decorate([
    ViewChild('sidebarLeftToggleElement'),
    __metadata("design:type", ElementRef)
], HeaderComponent.prototype, "sidebarLeftToggleElement", void 0);
__decorate([
    ViewChild('sidebarRightToggleElement'),
    __metadata("design:type", ElementRef)
], HeaderComponent.prototype, "sidebarRightToggleElement", void 0);
HeaderComponent = __decorate([
    Component({
        selector: 'mk-layout-header',
        template: "<header #headerElement class=\"main-header\">\n  <a [routerLink]=\"logoLink\" class=\"logo\">\n    <span class=\"logo-mini\"><ng-template [ngTemplateOutlet]=\"headerLogoMiniComponent?.templateRef\"></ng-template></span>\n    <span class=\"logo-lg\"><ng-template [ngTemplateOutlet]=\"headerLogoComponent?.templateRef\"></ng-template></span>\n  </a>\n  <nav class=\"navbar navbar-static-top\">\n    <a *ngIf=\"isSidebarLeftToggle\" #sidebarLeftToggleElement href=\"#\" class=\"sidebar-toggle {{sidebarLeftToggleIconClasses ? 'sidebar-toggle-custom-icon' : ''}}\">\n      <span class=\"sr-only\">Toggle navigation</span>\n      <ng-container *ngIf=\"sidebarLeftToggleIconClasses\">\n        <i [class]=\"sidebarLeftToggleIconClasses\"></i>\n      </ng-container>\n    </a>\n    <div *ngIf=\"isSidebarRightToggle\" class=\"sidebar-right-toggle\">\n      <a #sidebarRightToggleElement href=\"#\">\n        <i [class]=\"sidebarRightToggleIconClasses ? sidebarRightToggleIconClasses : 'fa fa-gears'\"></i>\n      </a>\n    </div>\n    <ng-content></ng-content>\n  </nav>\n</header>\n",
        styles: [":host{display:block}.sidebar-right-toggle{float:right}.sidebar-right-toggle a{padding:15px;display:block;line-height:20px;cursor:pointer}.sidebar-toggle-custom-icon:before{content:''}"]
    }),
    __metadata("design:paramtypes", [LayoutStore,
        NgZone,
        Renderer2,
        ElementRef,
        HeaderService])
], HeaderComponent);

let HeaderModule = class HeaderModule {
};
HeaderModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        exports: [HeaderComponent, HeaderLogoComponent, HeaderLogoMiniComponent],
        declarations: [HeaderComponent, HeaderLogoComponent, HeaderLogoMiniComponent]
    })
], HeaderModule);

/*
 *
 */
let CollapseAnimationDirective = class CollapseAnimationDirective {
    /**
     * @method constructor
     * @param elementRef [description]
     * @param ngZone     [description]
     * @param renderer2  [description]
     */
    constructor(elementRef, ngZone, renderer2) {
        this.elementRef = elementRef;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.firstStart = true;
        this.collapseAnimationDuration = 350;
        // tslint:disable-next-line:no-output-rename
        this.startEventEmitter = new EventEmitter();
        // tslint:disable-next-line:no-output-rename
        this.doneEventEmitter = new EventEmitter();
    }
    set _isCollapsed(value) {
        this.lastIsCollapsed = this.isCollapsed;
        this.isCollapsed = value;
        if (!this.firstStart) {
            this.emit('start');
            if (value) {
                this.collapse();
            }
            else if (value === false) {
                this.unCollapse();
            }
        }
    }
    /**
     * @method ngOnInit
     */
    ngOnInit() {
        if (this.collapseAnimationDuration && this.collapseAnimationDuration !== 350) {
            this.renderer2.setStyle(this.elementRef.nativeElement, 'transition-duration', `${this.collapseAnimationDuration}ms`);
        }
        if (this.collapseAnimationTiming) {
            this.renderer2.setStyle(this.elementRef.nativeElement, 'transition-timing-function', this.collapseAnimationTiming);
        }
    }
    /**
     * @method ngAfterContentInit
     */
    ngAfterContentInit() {
        this.emit('start');
        if (this.isCollapsed) {
            this.renderer2.setStyle(this.elementRef.nativeElement, 'display', 'none');
            this.renderer2.addClass(this.elementRef.nativeElement, 'collapsing');
        }
        this.emit('done');
        this.firstStart = false;
        this.subscriptions();
    }
    /**
     * [ngOnDestroy description]
     * @method ngOnDestroy
     * @return [description]
     */
    ngOnDestroy() {
        if (this.listener) {
            this.listener();
        }
    }
    /**
     * [subscriptions description]
     * @method subscriptions
     */
    subscriptions() {
        this.ngZone.runOutsideAngular(() => {
            this.listener = this.renderer2.listen(this.elementRef.nativeElement, 'transitionend', () => {
                if (!this.isCollapsed) {
                    this.renderer2.removeClass(this.elementRef.nativeElement, 'un-collapse');
                    this.renderer2.removeClass(this.elementRef.nativeElement, 'collapsing');
                }
                else {
                    this.renderer2.setStyle(this.elementRef.nativeElement, 'display', 'none');
                }
                requestAnimationFrame(() => {
                    this.renderer2.removeStyle(this.elementRef.nativeElement, 'height');
                    this.emit('done');
                    this.transitioning = false;
                });
            });
        });
    }
    /**
     * [unCollapse description]
     * @method unCollapse
     */
    unCollapse() {
        this.transitioning = true;
        this.renderer2.addClass(this.elementRef.nativeElement, 'un-collapse');
        this.renderer2.removeStyle(this.elementRef.nativeElement, 'display');
        this.renderer2.setStyle(this.elementRef.nativeElement, 'height', `${this.elementRef.nativeElement.scrollHeight}px`);
    }
    /**
     * [collapse description]
     * @method collapse
     */
    collapse() {
        requestAnimationFrame(() => {
            if (!this.transitioning) {
                this.renderer2.setStyle(this.elementRef.nativeElement, 'height', `${this.elementRef.nativeElement.offsetHeight}px`);
                this.renderer2.addClass(this.elementRef.nativeElement, 'collapsing');
            }
            this.transitioning = true;
            requestAnimationFrame(() => {
                this.renderer2.setStyle(this.elementRef.nativeElement, 'height', `0px`);
            });
        });
    }
    emit(phaseName) {
        const event = {
            element: this.elementRef.nativeElement,
            fromState: this.lastIsCollapsed === undefined ? 'void' : this.lastIsCollapsed ? '1' : '0',
            phaseName,
            toState: this.isCollapsed === undefined ? 'void' : this.isCollapsed ? '1' : '0',
            totalTime: this.collapseAnimationDuration,
            triggerName: 'mkCollapseAnimation'
        };
        if (phaseName === 'done') {
            this.doneEventEmitter.emit(event);
        }
        else if (phaseName === 'start') {
            this.startEventEmitter.emit(event);
        }
    }
};
CollapseAnimationDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], CollapseAnimationDirective.prototype, "collapseAnimationDuration", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CollapseAnimationDirective.prototype, "collapseAnimationTiming", void 0);
__decorate([
    Input('mkCollapseAnimation'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], CollapseAnimationDirective.prototype, "_isCollapsed", null);
__decorate([
    Output('mkCollapseAnimation.start'),
    __metadata("design:type", Object)
], CollapseAnimationDirective.prototype, "startEventEmitter", void 0);
__decorate([
    Output('mkCollapseAnimation.done'),
    __metadata("design:type", Object)
], CollapseAnimationDirective.prototype, "doneEventEmitter", void 0);
CollapseAnimationDirective = __decorate([
    Directive({
        selector: '[mkCollapseAnimation]'
    }),
    __metadata("design:paramtypes", [ElementRef,
        NgZone,
        Renderer2])
], CollapseAnimationDirective);

let AnimationsModule = class AnimationsModule {
};
AnimationsModule = __decorate([
    NgModule({
        exports: [CollapseAnimationDirective],
        declarations: [CollapseAnimationDirective]
    })
], AnimationsModule);

/*
 *
 */
let SidebarLeftToggleDirective = class SidebarLeftToggleDirective {
    /**
     * @method constructor
     * @param elementRef [description]
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
};
SidebarLeftToggleDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input('mkMenuToggle'),
    __metadata("design:type", Object)
], SidebarLeftToggleDirective.prototype, "item", void 0);
SidebarLeftToggleDirective = __decorate([
    Directive({
        selector: '[mkMenuToggle]'
    }),
    __metadata("design:paramtypes", [ElementRef])
], SidebarLeftToggleDirective);

let WrapperService = class WrapperService {
};
WrapperService = __decorate([
    Injectable()
], WrapperService);

let SidebarLeftComponent = class SidebarLeftComponent {
    /**
     * @method constructor
     * @param  changeDetectorRef  [description]
     * @param  layoutStore        [description]
     * @param  ngZone             [description]
     * @param  renderer2          [description]
     * @param  router             [description]
     * @param  routingService     [description]
     * @param  wrapperService     [description]
     * @param  headerService      [description]
     */
    constructor(changeDetectorRef, layoutStore, ngZone, renderer2, router, routingService, wrapperService, headerService) {
        this.changeDetectorRef = changeDetectorRef;
        this.layoutStore = layoutStore;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.router = router;
        this.routingService = routingService;
        this.wrapperService = wrapperService;
        this.headerService = headerService;
        this.collapsedItems = [];
        this.activatedItems = [];
        this.toggleListeners = [];
        this.listeners = [];
        this.itemsByIds = {};
        this.runningAnimations = 0;
        this.subscriptions = [];
    }
    /**
     * @method ngOnInit
     */
    ngOnInit() {
        this.subscriptions.push(this.layoutStore.sidebarLeftMenu.subscribe(value => {
            this.menu = value;
            this.monkeyPatchMenu(this.menu);
            if (this.initialized) {
                this.setMenuListeners(this.activeUrl);
                this.setSidebarListeners();
                this.setMenuTogglesListeners();
            }
            this.initialized = true;
        }));
        this.subscriptions.push(this.layoutStore.sidebarLeftMenuActiveUrl.subscribe(value => {
            this.activeUrl = value;
            this.setMenuListeners(value);
        }));
        this.subscriptions.push(this.routingService.events.subscribe((event) => {
            if (event instanceof NavigationEnd) {
                this.activeUrl = event.url;
                this.setMenuListeners(event.url);
            }
        }));
        this.setSidebarListeners();
    }
    /**
     * @method ngAfterViewInit
     */
    ngAfterViewInit() {
        this.setMenuTogglesListeners();
        this.checkMenuWithoutChildren();
    }
    /**
     * @method ngOnDestroy
     */
    ngOnDestroy() {
        this.subscriptions = removeSubscriptions(this.subscriptions);
        this.listeners = removeListeners(this.listeners);
        this.toggleListeners = removeListeners(this.toggleListeners);
    }
    /**
     * [setSidebarListeners description]
     * @method setSidebarListeners
     */
    setSidebarListeners() {
        this.subscriptions.push(this.layoutStore.layout.subscribe((value) => {
            this.layout = value;
            this.setSidebarHeight();
        }));
        this.subscriptions.push(this.layoutStore.windowInnerHeight.subscribe((value) => {
            this.windowInnerHeight = value;
            this.setSidebarHeight();
        }));
        this.subscriptions.push(this.layoutStore.sidebarLeftMenu.subscribe(() => {
            this.changeDetectorRef.detectChanges();
        }));
        this.ngZone.runOutsideAngular(() => {
            this.listeners.push(this.renderer2.listen(this.sidebarElement.nativeElement, 'mouseenter', () => {
                this.layoutStore.sidebarLeftMouseOver(true);
            }));
            this.listeners.push(this.renderer2.listen(this.sidebarElement.nativeElement, 'mouseleave', () => {
                this.layoutStore.sidebarLeftMouseOver(false);
            }));
        });
        this.subscriptions.push(this.layoutStore.windowInnerWidth.subscribe((value) => {
            this.windowInnerWidth = value;
            if (!this.isSidebarLeftCollapsed && this.windowInnerWidth <= 767) {
                this.layoutStore.sidebarLeftCollapsed(true);
            }
            else if (this.windowInnerWidth > 767 && this.isSidebarLeftCollapsed && !this.isSidebarLeftExpandOnOver) {
                this.layoutStore.sidebarLeftCollapsed(false);
            }
        }));
        this.subscriptions.push(this.layoutStore.isSidebarLeftMouseOver.subscribe((value) => {
            this.isSidebarLeftMouseOver = value;
            if (this.isSidebarLeftExpandOnOver) {
                this.layoutStore.sidebarLeftCollapsed(!value);
            }
        }));
        this.subscriptions.push(this.layoutStore.isSidebarLeftExpandOnOver.subscribe((value) => {
            this.isSidebarLeftExpandOnOver = value;
            if (this.windowInnerWidth > 767 && this.isSidebarLeftCollapsed !== undefined) {
                this.layoutStore.sidebarLeftCollapsed(value);
            }
        }));
        this.subscriptions.push(this.layoutStore.isSidebarLeftCollapsed.subscribe((value) => {
            this.isSidebarLeftCollapsed = value;
            if (this.windowInnerWidth <= 767) {
                if (value) {
                    this.renderer2.removeClass(this.wrapperService.wrapperElementRef.nativeElement, 'sidebar-open');
                }
                else {
                    this.renderer2.addClass(this.wrapperService.wrapperElementRef.nativeElement, 'sidebar-open');
                }
            }
            else {
                if (this.isSidebarLeftExpandOnOver && !this.isSidebarLeftMouseOver && !value) {
                    this.layoutStore.sidebarLeftExpandOnOver(false);
                }
                if (value) {
                    this.renderer2.addClass(this.wrapperService.wrapperElementRef.nativeElement, 'sidebar-collapse');
                    if (this.isSidebarLeftExpandOnOver) {
                        this.renderer2.removeClass(this.wrapperService.wrapperElementRef.nativeElement, 'sidebar-expanded-on-hover');
                    }
                }
                else {
                    this.renderer2.removeClass(this.wrapperService.wrapperElementRef.nativeElement, 'sidebar-collapse');
                    if (this.isSidebarLeftExpandOnOver) {
                        this.renderer2.addClass(this.wrapperService.wrapperElementRef.nativeElement, 'sidebar-expanded-on-hover');
                    }
                }
            }
        }));
        this.subscriptions.push(this.layoutStore.isSidebarLeftMini.subscribe((value) => {
            if (value) {
                this.renderer2.addClass(this.wrapperService.wrapperElementRef.nativeElement, 'sidebar-mini');
            }
            else {
                this.renderer2.removeClass(this.wrapperService.wrapperElementRef.nativeElement, 'sidebar-mini');
            }
        }));
    }
    /**
     * [setMenuListeners description]
     * @method setMenuListeners
     */
    setMenuListeners(url) {
        if (url === '/') {
            this.activeItems(url);
            this.changeDetectorRef.detectChanges();
        }
        else {
            const primaryOutlet = this.router.parseUrl(url).root.children[PRIMARY_OUTLET];
            if (primaryOutlet) {
                this.activeItems(primaryOutlet.toString());
                this.changeDetectorRef.detectChanges();
            }
        }
        if (this.windowInnerWidth <= 767 || this.isSidebarLeftExpandOnOver) {
            this.layoutStore.sidebarLeftCollapsed(true);
        }
    }
    /**
     * [getIconClasses description]
     * @method getIconClasses
     * @param item [description]
     * @return [description]
     */
    getIconClasses(item) {
        if (item.iconClasses || item.iconClasses === '') {
            return item.iconClasses;
        }
        else {
            return 'fa fa-circle-o';
        }
    }
    /**
     * [visibilityStateStart description]
     * @method visibilityStateStart
     * @param event [description]
     */
    visibilityStateStart(event) {
        this.runningAnimations++;
        this.ngZone.runOutsideAngular(() => {
            setTimeout(() => {
                this.runningAnimations--;
                if (!this.runningAnimations) {
                    this.layoutStore.setSidebarLeftElementHeight(this.sidebarElement.nativeElement.offsetHeight);
                }
            }, event.totalTime);
        });
    }
    /**
     * [uncollapseItemParents description]
     * @method uncollapseItemParents
     * @param item           [description]
     * @param isActive       [description]
     */
    uncollapseItemParents(item, isActive = false) {
        if (isActive) {
            item.isActive = true;
            this.activatedItems.push(item);
        }
        item.isCollapsed = false;
        this.collapsedItems.push(item);
        if (item.parentId) {
            this.uncollapseItemParents(this.itemsByIds[item.parentId], isActive);
        }
    }
    /**
     * [findItemsByUrl description]
     * @method findItemsByUrl
     * @param url   [description]
     * @param items [description]
     * @param returnItems [description]
     * @return [description]
     */
    findItemsByUrl(url, items, returnItems = []) {
        items.forEach((item) => {
            if (item.route === url) {
                returnItems.push(item);
            }
            else if (item.children) {
                this.findItemsByUrl(url, item.children, returnItems);
            }
        });
        return returnItems;
    }
    /**
     * [activeItems description]
     * @method activeItems
     * @param url [description]
     */
    activeItems(url) {
        this.activatedItems.forEach((item) => {
            item.isActive = false;
        });
        this.activatedItems = [];
        this.collapsedItems.forEach((item) => {
            item.isActive = false;
            item.isCollapsed = true;
        });
        this.collapsedItems = [];
        const items = this.findItemsByUrl(url, this.menu);
        items.forEach(item => {
            item.isActive = true;
            this.uncollapseItemParents(item, true);
            this.activatedItems.push(item);
        });
    }
    /**
     * [monkeyPatchMenu description]
     * @method monkeyPatchMenu
     * @param items    [description]
     * @param parentId [description]
     */
    monkeyPatchMenu(items, parentId) {
        items.forEach((item, index) => {
            item.id = parentId ? Number(parentId + '' + (index + 1)) : index + 1;
            if (parentId) {
                item.parentId = parentId;
            }
            if (!item.disableCollapse) {
                item.isCollapsed = true;
            }
            item.isActive = false;
            if (parentId || item.children) {
                this.itemsByIds[item.id] = item;
            }
            if (item.children) {
                this.monkeyPatchMenu(item.children, item.id);
            }
        });
    }
    /**
     * [setMenuTogglesListeners description]
     * @method setMenuTogglesListeners
     */
    setMenuTogglesListeners() {
        this.toggleListeners = removeListeners(this.toggleListeners);
        this.ngZone.runOutsideAngular(() => {
            this.sidebarLeftToggleDirectives.forEach((menuToggle) => {
                this.toggleListeners.push(this.renderer2.listen(menuToggle.elementRef.nativeElement, 'click', (event) => {
                    event.preventDefault();
                    if (menuToggle.item.isCollapsed) {
                        this.collapsedItems.forEach((item) => {
                            if (!item.disableCollapse) {
                                item.isCollapsed = true;
                            }
                        });
                        this.collapsedItems = [];
                        this.uncollapseItemParents(menuToggle.item);
                    }
                    else {
                        menuToggle.item.isCollapsed = !menuToggle.item.isCollapsed;
                    }
                    this.changeDetectorRef.detectChanges();
                }));
            });
        });
    }
    /**
     * [checkMenuWithoutChildren description]
     * @method checkMenuWithoutChildren
     */
    checkMenuWithoutChildren() {
        let menuHaveChildren;
        this.menu.forEach((item) => {
            if (item.children) {
                return menuHaveChildren = true;
            }
        });
        if (!menuHaveChildren) {
            this.ngZone.runOutsideAngular(() => {
                setTimeout(() => {
                    this.layoutStore.setSidebarLeftElementHeight(this.sidebarElement.nativeElement.offsetHeight);
                });
            });
        }
    }
    /**
     * [setSidebarHeight description]
     * @method setSidebarHeight
     */
    setSidebarHeight() {
        if (this.layout === 'fixed') {
            const height = this.windowInnerHeight - this.headerService.offsetHeight;
            if (height && height !== this.sidebarHeight) {
                this.sidebarHeight = height;
                this.sidebarOverflow = 'auto';
                this.changeDetectorRef.detectChanges();
            }
        }
        else if (this.sidebarHeight) {
            this.sidebarOverflow = this.sidebarHeight = null;
            this.changeDetectorRef.detectChanges();
        }
    }
};
SidebarLeftComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: LayoutStore },
    { type: NgZone },
    { type: Renderer2 },
    { type: Router },
    { type: RoutingService },
    { type: WrapperService },
    { type: HeaderService }
];
__decorate([
    ViewChild('sidebarElement', { static: true }),
    __metadata("design:type", ElementRef)
], SidebarLeftComponent.prototype, "sidebarElement", void 0);
__decorate([
    ViewChildren(SidebarLeftToggleDirective),
    __metadata("design:type", QueryList)
], SidebarLeftComponent.prototype, "sidebarLeftToggleDirectives", void 0);
SidebarLeftComponent = __decorate([
    Component({
        selector: 'mk-layout-sidebar-left',
        template: "<aside class=\"main-sidebar\">\n  <section class=\"sidebar\" #sidebarElement [style.height.px]=\"sidebarHeight\" [style.overflow]=\"sidebarOverflow\">\n    <ng-content></ng-content>\n  \t<ul class=\"sidebar-menu\">\n      <ng-container *ngFor=\"let item of menu\">\n        <ng-container *ngTemplateOutlet=\"sidebarInner; context: {item: item}\"></ng-container>\n      </ng-container>\n  \t</ul>\n  </section>\n</aside>\n\n<ng-template #sidebarInner let-item=\"item\">\n  <li [class.active]=\"item.isActive\" [class.header]=\"item.separator\" [class.menu-open]=\"!item.isCollapsed\">\n    <span *ngIf=\"item.separator\">{{item.label}}</span>\n    <a *ngIf=\"!item.separator && item.route\" [routerLink]=\"item.route\">\n    \t<i [class]=\"getIconClasses(item)\"></i><span>{{item.label}}</span>\n    \t<span *ngIf=\"item.children || item.pullRights\" class=\"pull-right-container\">\n    \t\t<span *ngFor=\"let rightItem of item.pullRights\" class=\"pull-right {{rightItem.classes}}\">{{rightItem.text}}</span>\n    \t  <i *ngIf=\"!item.pullRights\" class=\"fa fa-angle-left pull-right\"></i>\n    \t</span>\n    </a>\n    <a *ngIf=\"!item.separator && !item.route\" href=\"#\" [mkMenuToggle]=\"item\">\n    \t<i [class]=\"getIconClasses(item)\"></i><span>{{item.label}}</span>\n    \t<span *ngIf=\"item.children || item.pullRights\" class=\"pull-right-container\">\n    \t\t<span *ngFor=\"let rightItem of item.pullRights\" class=\"pull-right {{rightItem.classes}}\">{{rightItem.text}}</span>\n    \t  <i *ngIf=\"!item.pullRights\" class=\"fa fa-angle-left pull-right\"></i>\n    \t</span>\n    </a>\n    <ul *ngIf=\"item.children\" [mkCollapseAnimation]=\"item.isCollapsed\" (mkCollapseAnimation.start)=\"visibilityStateStart($event)\" class=\"treeview-menu\">\n      <ng-container *ngFor=\"let item of item.children\">\n        <ng-container *ngTemplateOutlet=\"sidebarInner; context: {item: item}\"></ng-container>\n      </ng-container>\n    </ul>\n  </li>\n</ng-template>\n",
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: [".treeview-menu.collapse{display:none}.treeview-menu,.treeview-menu.collapse.in{display:block}"]
    }),
    __metadata("design:paramtypes", [ChangeDetectorRef,
        LayoutStore,
        NgZone,
        Renderer2,
        Router,
        RoutingService,
        WrapperService,
        HeaderService])
], SidebarLeftComponent);

let SidebarLeftModule = class SidebarLeftModule {
};
SidebarLeftModule = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule, AnimationsModule],
        exports: [SidebarLeftComponent],
        declarations: [SidebarLeftToggleDirective, SidebarLeftComponent]
    })
], SidebarLeftModule);

let SidebarRightComponent = class SidebarRightComponent {
    constructor(elementRef, renderer2, layoutStore, sidebarRightService, wrapperService) {
        this.elementRef = elementRef;
        this.renderer2 = renderer2;
        this.layoutStore = layoutStore;
        this.sidebarRightService = sidebarRightService;
        this.wrapperService = wrapperService;
        this.listeners = [];
        this.subscriptions = [];
    }
    /**
     * @method ngOnInit
     */
    ngOnInit() {
        this.renderer2.addClass(this.elementRef.nativeElement, 'control-sidebar');
        this.subscriptions.push(this.layoutStore.isSidebarRightCollapsed.subscribe(value => {
            this.isSidebarRightCollapsed = value;
            if (!value) {
                this.renderer2.addClass(this.elementRef.nativeElement, 'control-sidebar-open');
                if (!this.isSidebarRightOverContent) {
                    this.renderer2.addClass(this.wrapperService.wrapperElementRef.nativeElement, 'control-sidebar-open');
                }
            }
            else {
                this.renderer2.removeClass(this.elementRef.nativeElement, 'control-sidebar-open');
                if (!this.isSidebarRightOverContent) {
                    this.renderer2.removeClass(this.wrapperService.wrapperElementRef.nativeElement, 'control-sidebar-open');
                }
            }
        }));
        this.subscriptions.push(this.layoutStore.isSidebarRightOverContent.subscribe((value) => {
            this.isSidebarRightOverContent = value;
            if (!this.isSidebarRightCollapsed) {
                if (value) {
                    this.renderer2.removeClass(this.wrapperService.wrapperElementRef.nativeElement, 'control-sidebar-open');
                }
                else {
                    this.renderer2.addClass(this.wrapperService.wrapperElementRef.nativeElement, 'control-sidebar-open');
                }
            }
        }));
        this.subscriptions.push(this.layoutStore.sidebarRightSkin.subscribe((value) => {
            if (this.skin !== value) {
                this.renderer2.removeClass(this.elementRef.nativeElement, `control-sidebar-${this.skin}`);
            }
            this.skin = value;
            this.renderer2.addClass(this.elementRef.nativeElement, `control-sidebar-${value}`);
        }));
    }
    /**
     * @method ngAfterViewInit
     */
    ngAfterViewInit() {
        this.sidebarRightService.elementRef = this.sidebarContentElement;
    }
    /**
     * @method ngOnDestroy
     */
    ngOnDestroy() {
        this.listeners = removeListeners(this.listeners);
        this.subscriptions = removeSubscriptions(this.subscriptions);
    }
};
SidebarRightComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: LayoutStore },
    { type: SidebarRightService },
    { type: WrapperService }
];
__decorate([
    ViewChild('sidebarContentElement', { static: true }),
    __metadata("design:type", ElementRef)
], SidebarRightComponent.prototype, "sidebarContentElement", void 0);
SidebarRightComponent = __decorate([
    Component({
        selector: 'mk-layout-sidebar-right',
        template: "<div #sidebarContentElement class=\"control-sidebar-content\">\n  <ng-content></ng-content>\n</div>\n<div class=\"control-sidebar-bg\"></div>\n",
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: [":host{display:block;height:100%}.control-sidebar-bg{z-index:-1}/deep/ .tab-content{padding:10px 15px}"]
    }),
    __metadata("design:paramtypes", [ElementRef,
        Renderer2,
        LayoutStore,
        SidebarRightService,
        WrapperService])
], SidebarRightComponent);

let SidebarRightModule = class SidebarRightModule {
};
SidebarRightModule = __decorate([
    NgModule({
        imports: [CommonModule],
        exports: [SidebarRightComponent],
        declarations: [SidebarRightComponent]
    })
], SidebarRightModule);

let WrapperComponent = class WrapperComponent {
    constructor(elementRef, renderer2, layoutStore, wrapperService, ngZone) {
        this.elementRef = elementRef;
        this.renderer2 = renderer2;
        this.layoutStore = layoutStore;
        this.wrapperService = wrapperService;
        this.ngZone = ngZone;
        this.listeners = [];
        this.subscriptions = [];
    }
    /**
     * [ngOnInit description]
     * @method ngOnInit
     */
    ngOnInit() {
        this.layoutStore.setWindowInnerHeight(window.innerHeight);
        this.layoutStore.setWindowInnerWidth(window.innerWidth);
        this.wrapperService.wrapperElementRef = this.elementRef;
        this.subscriptions.push(this.layoutStore.wrapperClasses.subscribe((value) => {
            this.classes = value ? value : null;
        }));
        this.ngZone.runOutsideAngular(() => {
            this.listeners.push(this.renderer2.listen('window', 'resize', throttle(() => {
                this.layoutStore.setWindowInnerHeight(window.innerHeight);
                this.layoutStore.setWindowInnerWidth(window.innerWidth);
            }, 250)));
        });
        this.subscriptions.push(this.layoutStore.layout.subscribe((value) => {
            value === 'fixed' ? this.renderer2.addClass(this.elementRef.nativeElement, 'fixed') :
                this.renderer2.removeClass(this.elementRef.nativeElement, 'fixed');
            value === 'boxed' ? this.renderer2.addClass(this.elementRef.nativeElement, 'layout-boxed') :
                this.renderer2.removeClass(this.elementRef.nativeElement, 'layout-boxed');
        }));
        this.subscriptions.push(this.layoutStore.skin.subscribe((value) => {
            if (value) {
                if (this.skin && this.skin !== value) {
                    this.renderer2.removeClass(this.elementRef.nativeElement, `skin-${this.skin}`);
                }
                this.skin = value;
                this.renderer2.addClass(this.elementRef.nativeElement, `skin-${this.skin}`);
            }
        }));
    }
    /**
     * @method ngOnDestroy
     */
    ngOnDestroy() {
        this.subscriptions = removeSubscriptions(this.subscriptions);
        this.listeners = removeListeners(this.listeners);
    }
};
WrapperComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: LayoutStore },
    { type: WrapperService },
    { type: NgZone }
];
WrapperComponent = __decorate([
    Component({
        selector: 'mk-layout-wrapper',
        template: "<div class=\"wrapper overflow\" [ngClass]=\"classes\">\n  <ng-content></ng-content>\n</div>\n",
        styles: [".wrapper.overflow{overflow:hidden}:host{display:block}:host /deep/ .sidebar-right-toggle>a{color:#fff}:host.sidebar-mini.sidebar-collapse /deep/ .treeview-menu.collapsing{height:auto!important}:host /deep/ .sidebar-right-toggle>a:hover{background:rgba(0,0,0,.1)}:host.skin-black /deep/ .sidebar-right-toggle>a,:host.skin-black-light /deep/ .sidebar-right-toggle>a{color:#333;border-right-width:0}:host.skin-black /deep/ .sidebar-right-toggle>a:hover,:host.skin-black-light /deep/ .sidebar-right-toggle>a:hover{background-color:#fff;color:#999}:host.skin-black /deep/ .sidebar-right-toggle>a{border-left:1px solid #eee}:host.skin-black-light /deep/ .sidebar-right-toggle>a{border-left:1px solid #d2d6de}"]
    }),
    __metadata("design:paramtypes", [ElementRef,
        Renderer2,
        LayoutStore,
        WrapperService,
        NgZone])
], WrapperComponent);

let WrapperModule = class WrapperModule {
};
WrapperModule = __decorate([
    NgModule({
        imports: [CommonModule],
        exports: [WrapperComponent],
        declarations: [WrapperComponent]
    })
], WrapperModule);

let LayoutService = class LayoutService {
    /**
     * @method constructor
     * @param routingService [description]
     */
    constructor(router) {
        this.router = router;
        this.isCustomLayout = new BehaviorSubject(false);
        this.init();
    }
    /**
     * [init description]
     * @method init
     * @return [description]
     */
    init() {
        this.router.events.subscribe((event) => {
            if (event instanceof ActivationStart) {
                this.customLayout = event.snapshot.data.customLayout;
                this.isCustomLayout.next(!!this.customLayout);
            }
        });
    }
};
LayoutService.ctorParameters = () => [
    { type: Router }
];
LayoutService = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [Router])
], LayoutService);

/**
 * [InjectionToken description]
 */
const LayoutConfigToken = new InjectionToken('layoutConfig');
/**
 * [layoutStoreFactory description]
 */
function layoutStoreFactory(layoutConfig) {
    return new LayoutStore(layoutConfig);
}
/**
 * [layoutProviders description]
 */
function layoutProvider(layoutConfig) {
    return [{
            provide: LayoutStore,
            useFactory: layoutStoreFactory,
            deps: [LayoutConfigToken]
        }, {
            provide: LayoutConfigToken,
            useValue: layoutConfig
        }
    ];
}

var LayoutModule_1;
let LayoutModule = LayoutModule_1 = class LayoutModule {
    /**
     * @method constructor
     * @param parentModule [description]
     */
    constructor(parentModule) {
        if (parentModule) {
            throw new Error('LayoutModule is already loaded. Import it in the AppModule only!');
        }
    }
    /**
     * [forRoot description]
     * @method forRoot
     * @param  layoutConfig [description]
     * @return [description]
     */
    static forRoot(layoutConfig) {
        return {
            ngModule: LayoutModule_1,
            providers: [...layoutProvider(layoutConfig), LayoutService]
        };
    }
};
LayoutModule.ctorParameters = () => [
    { type: LayoutModule, decorators: [{ type: Optional }, { type: SkipSelf }] }
];
LayoutModule = LayoutModule_1 = __decorate([
    NgModule({
        imports: [CommonModule, RouterModule],
        exports: [ContentModule, FooterModule, HeaderModule, SidebarLeftModule, SidebarRightModule, WrapperModule],
        providers: [RoutingService, WrapperService, SidebarRightService, HeaderService, FooterService]
    }),
    __param(0, Optional()), __param(0, SkipSelf()),
    __metadata("design:paramtypes", [LayoutModule])
], LayoutModule);

const colorsAliases = [
    'default',
    'primary',
    'danger',
    'warning',
    'info',
    'success'
];
const colors = {
    aqua: '#00c0ef',
    'aqua-active': '#00a7d0',
    black: '#111111',
    'black-active': '#000000',
    blue: '#0073b7',
    'blue-active': '#005384',
    fuchsia: '#f012be',
    'fuchsia-active': '#db0ead',
    green: '#00a65a',
    'green-active': '#008d4c',
    gray: '#d2d6de',
    'gray-active': '#b5bbc8',
    'gray-light': '#f7f7f7',
    'light-blue': '#3c8dbc',
    'light-blue-active': '#357ca5',
    lime: '#01ff70',
    'lime-active': '#00e765',
    maroon: '#d81b60',
    'maroon-active': '#ca195a',
    navy: '#001f3f',
    'navy-active': '#001a35',
    olive: '#3d9970',
    'olive-active': '#368763',
    orange: '#ff851b',
    'orange-active': '#ff7701',
    purple: '#605ca8',
    'purple-active': '#555299',
    red: '#dd4b39',
    'red-active': '#d33724',
    teal: '#39cccc',
    'teal-active': '#30bbbb',
    yellow: '#f39c12',
    'yellow-active': '#db8b0b',
};

/*
 *
 */
let ColorService = class ColorService {
    /**
     * @method constructor
     * @param renderer2 [description]
     * @param elementRef [description]
     */
    constructor(renderer2, elementRef) {
        this.renderer2 = renderer2;
        this.elementRef = elementRef;
    }
    /**
     * [setBackgroundColor description]
     * @method setBackgroundColor
     * @param  color              [description]
     * @param  condition          [description]
     * @param  property           [description]
     * @param  prefix             [description]
     */
    setBackgroundColor(color, condition, property, prefix) {
        if (color && condition) {
            this.resetBackgroundColor();
            if (colors[color]) {
                this.renderer2.addClass(this.elementRef.nativeElement, 'bg-color');
                this.currentBackgroundStyle = { property, color: colors[color] };
                this.renderer2.setStyle(this.elementRef.nativeElement, property, colors[color]);
            }
            else {
                this.renderer2.removeClass(this.elementRef.nativeElement, 'bg-color');
                if (color.indexOf('#') === 0 || color.indexOf('rgb') === 0) {
                    this.currentBackgroundStyle = { property, color };
                    this.renderer2.setStyle(this.elementRef.nativeElement, property, color);
                }
                else if (colorsAliases.indexOf(color) !== -1) {
                    this.currentBackgroundClass = prefix ? `${prefix}-${color}` : color;
                    this.renderer2.addClass(this.elementRef.nativeElement, this.currentBackgroundClass);
                }
            }
        }
    }
    /**
     * [resetBackgroundColor description]
     * @method resetBackgroundColor
     */
    resetBackgroundColor() {
        if (this.currentBackgroundStyle) {
            this.renderer2.removeStyle(this.elementRef.nativeElement, this.currentBackgroundStyle.property, this.currentBackgroundStyle.color);
        }
        else if (this.currentBackgroundClass) {
            this.renderer2.removeClass(this.elementRef.nativeElement, this.currentBackgroundClass);
        }
    }
    /**
     * [setFontColor description]
     * @method setFontColor
     * @param  color        [description]
     */
    setFontColor(color) {
        if (color) {
            this.resetFontColor();
            if (color.startsWith('#') || color.startsWith('rgb')) {
                this.currentFontStyle = color;
                this.renderer2.setStyle(this.elementRef.nativeElement, 'color', color);
            }
            else {
                this.currentFontClass = `text-${color}`;
                this.renderer2.addClass(this.elementRef.nativeElement, this.currentFontClass);
            }
        }
    }
    /**
     * [resetFontColor description]
     * @method resetFontColor
     * @return [description]
     */
    resetFontColor() {
        if (this.currentFontStyle) {
            this.renderer2.removeStyle(this.elementRef.nativeElement, 'color', this.currentFontStyle);
        }
        else if (this.currentFontClass) {
            this.renderer2.removeClass(this.elementRef.nativeElement, this.currentFontClass);
        }
    }
};
ColorService.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
ColorService = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [Renderer2,
        ElementRef])
], ColorService);

let BackgroundColorDirective = class BackgroundColorDirective {
    /**
     * @method constructor
     * @param elementRef   [description]
     * @param renderer2    [description]
     * @param colorService [description]
     */
    constructor(elementRef, renderer2, colorService) {
        this.elementRef = elementRef;
        this.renderer2 = renderer2;
        this.colorService = colorService;
        this.condition = true;
    }
    set setPrefix(prefix) {
        this.prefix = prefix;
        this.colorService.setBackgroundColor(this.color, this.condition, this.property, this.prefix);
    }
    set setColor(color) {
        this.color = color;
        this.colorService.setBackgroundColor(this.color, this.condition, this.property, this.prefix);
    }
};
BackgroundColorDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ColorService }
];
__decorate([
    Input('mkColorCondition'),
    __metadata("design:type", Object)
], BackgroundColorDirective.prototype, "condition", void 0);
__decorate([
    Input('mkColorPrefix'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], BackgroundColorDirective.prototype, "setPrefix", null);
__decorate([
    Input('mkColorProperty'),
    __metadata("design:type", String)
], BackgroundColorDirective.prototype, "property", void 0);
__decorate([
    Input('mkColor'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], BackgroundColorDirective.prototype, "setColor", null);
BackgroundColorDirective = __decorate([
    Directive({
        selector: '[mkColor]',
        providers: [ColorService]
    }),
    __metadata("design:paramtypes", [ElementRef,
        Renderer2,
        ColorService])
], BackgroundColorDirective);
let ColorDirective = class ColorDirective {
    /**
     * @method constructor
     * @param elementRef   [description]
     * @param renderer2    [description]
     * @param colorService [description]
     */
    constructor(elementRef, renderer2, colorService) {
        this.elementRef = elementRef;
        this.renderer2 = renderer2;
        this.colorService = colorService;
    }
    set color(color) {
        this.colorService.setFontColor(color);
    }
};
ColorDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ColorService }
];
__decorate([
    Input('mkFontColor'),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], ColorDirective.prototype, "color", null);
ColorDirective = __decorate([
    Directive({
        selector: '[mkFontColor]',
        providers: [ColorService]
    }),
    __metadata("design:paramtypes", [ElementRef,
        Renderer2,
        ColorService])
], ColorDirective);

let ColorModule = class ColorModule {
};
ColorModule = __decorate([
    NgModule({
        exports: [BackgroundColorDirective, ColorDirective],
        declarations: [BackgroundColorDirective, ColorDirective]
    })
], ColorModule);

/*
 *
 */
let AccordionToggleDirective = class AccordionToggleDirective {
    /**
     * @method constructor
     * @param elementRef [description]
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
};
AccordionToggleDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input('mkAccordionToggle'),
    __metadata("design:type", Object)
], AccordionToggleDirective.prototype, "accordionComponent", void 0);
AccordionToggleDirective = __decorate([
    Directive({
        selector: '[mkAccordionToggle]'
    }),
    __metadata("design:paramtypes", [ElementRef])
], AccordionToggleDirective);

var AccordionGroupComponent_1;
/*
 *
 */
let AccordionHeaderComponent = class AccordionHeaderComponent {
};
__decorate([
    ViewChild('templateRef', { static: true }),
    __metadata("design:type", TemplateRef)
], AccordionHeaderComponent.prototype, "templateRef", void 0);
AccordionHeaderComponent = __decorate([
    Component({
        selector: 'mk-accordion-header',
        template: '<ng-template #templateRef><ng-content></ng-content></ng-template>'
    })
], AccordionHeaderComponent);
/*
 *
 */
let AccordionContentComponent = class AccordionContentComponent {
};
__decorate([
    ViewChild('templateRef', { static: true }),
    __metadata("design:type", TemplateRef)
], AccordionContentComponent.prototype, "templateRef", void 0);
AccordionContentComponent = __decorate([
    Component({
        selector: 'mk-accordion-content',
        template: '<ng-template #templateRef><ng-content></ng-content></ng-template>'
    })
], AccordionContentComponent);
/*
 *
 */
let AccordionComponent = class AccordionComponent {
    constructor() {
        this.contentStyleClass = 'box-body';
        this.headerStyleClass = 'box-header with-border';
    }
    /**
     * @method ngOnInit
     */
    ngOnInit() {
        this.headerStyleColor = this.headerColor;
        if (!this.header && !this.accordionHeaderComponent) {
            throw new Error('Attribute "header" OR Component "mk-+accordion-header" is required for component "mk-+accordion"');
        }
        if (this.accordionContentComponent) {
            this.contentTemplateRef = this.accordionContentComponent.templateRef;
        }
        else {
            this.contentTemplateRef = this.templateRef;
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], AccordionComponent.prototype, "borderColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AccordionComponent.prototype, "contentColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AccordionComponent.prototype, "contentStyleClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AccordionComponent.prototype, "header", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AccordionComponent.prototype, "headerColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AccordionComponent.prototype, "headerColorHover", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AccordionComponent.prototype, "headerStyleClass", void 0);
__decorate([
    ContentChild(AccordionHeaderComponent, /* TODO: add static flag */ {}),
    __metadata("design:type", AccordionHeaderComponent)
], AccordionComponent.prototype, "accordionHeaderComponent", void 0);
__decorate([
    ContentChild(AccordionContentComponent, /* TODO: add static flag */ {}),
    __metadata("design:type", AccordionContentComponent)
], AccordionComponent.prototype, "accordionContentComponent", void 0);
__decorate([
    ViewChild('templateRef', { static: true }),
    __metadata("design:type", TemplateRef)
], AccordionComponent.prototype, "templateRef", void 0);
AccordionComponent = __decorate([
    Component({
        selector: 'mk-accordion',
        template: '<ng-template #templateRef><ng-content></ng-content></ng-template>'
    })
], AccordionComponent);
/*
 *
 */
let AccordionGroupComponent = AccordionGroupComponent_1 = class AccordionGroupComponent {
    /**
     * @method constructor
     * @param changeDetectorRef [description]
     * @param ngZone            [description]
     * @param renderer2         [description]
     */
    constructor(changeDetectorRef, ngZone, renderer2) {
        this.changeDetectorRef = changeDetectorRef;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.activeIndex = [0];
        // @TODO change types for listeners to all files
        this.listeners = [];
        // @TODO change types for subscriptions to all files
        this.subscriptions = [];
        this.styleClass = 'box-group';
        this.collapseStart = new EventEmitter();
        this.collapseDone = new EventEmitter();
    }
    set _activeIndex(value) {
        this.activeIndex = value instanceof Array ? value : [value];
    }
    /**
     * [headerMouseLeave description]
     * @method headerMouseLeave
     * @param accordion [description]
     */
    static headerMouseLeave(accordion) {
        accordion.headerStyleColor = accordion.headerColor;
    }
    /**
     * [headerMouseEnter description]
     * @method headerMouseEnter
     * @param accordion [description]
     */
    static headerMouseEnter(accordion) {
        if (accordion.headerColorHover) {
            accordion.headerStyleColor = accordion.headerColorHover;
        }
    }
    /**
     * @method ngAfterViewInit
     */
    ngAfterContentInit() {
        this.setAccordionsIndex();
        this.updateAccordionIsCollapsed();
        this.subscriptions.push(this.accordionComponents.changes.subscribe(() => {
            this.setAccordionsIndex();
        }));
    }
    /**
     * @method ngAfterViewInit
     */
    ngAfterViewInit() {
        this.setAccordionsToggle();
        this.subscriptions.push(this.accordionToggleDirectives.changes.subscribe(() => {
            this.setAccordionsToggle();
        }));
    }
    /**
     * [ngOnChanges description]
     * @method ngOnChanges
     * @param changes [description]
     * @return [description]
     */
    ngOnChanges(changes) {
        if (changes._activeIndex.firstChange === false) {
            this.updateAccordionIsCollapsed();
        }
    }
    /**
     * @method ngOnDestroy
     */
    ngOnDestroy() {
        removeListeners(this.listeners);
        removeSubscriptions(this.subscriptions);
    }
    /**
     * [toggleAccordion description]
     * @method toggleAccordion
     * @param event       [description]
     * @param toggleIndex [description]
     */
    toggleAccordion(event, toggleIndex) {
        event.preventDefault();
        const indexOf = this.activeIndex.indexOf(toggleIndex);
        if (indexOf === -1) {
            if (this.isMultiple) {
                this.activeIndex.push(toggleIndex);
            }
            else {
                this.activeIndex = [toggleIndex];
            }
        }
        else {
            if (this.isMultiple) {
                this.activeIndex.splice(indexOf, 1);
            }
            else {
                this.activeIndex = [];
            }
        }
        this.updateAccordionIsCollapsed();
    }
    /**
     * [collapseStart description]
     * @method collapseStart
     * @param event [description]
     * @param accordion [description]
     */
    onCollapseStart(event, accordion) {
        accordion.isCollapsing = true;
        this.collapseStart.emit({ animationEvent: event, index: accordion.index });
    }
    /**
     * [collapseDone description]
     * @method collapseDone
     * @param event [description]
     * @param accordion [description]
     */
    onCollapseDone(event, accordion) {
        accordion.isCollapsing = false;
        this.collapseDone.emit({ animationEvent: event, index: accordion.index });
    }
    /**
     * [setAccordionsIndex description]
     * @method setAccordionsIndex
     */
    setAccordionsIndex() {
        this.accordionComponents.forEach((accordion, index) => {
            accordion.index = index;
        });
    }
    /**
     * [setAccordionsToggle description]
     * @method setAccordionsToggle
     */
    setAccordionsToggle() {
        this.listeners = removeListeners(this.listeners);
        this.ngZone.runOutsideAngular(() => {
            this.accordionToggleDirectives.forEach((accordionToggle) => {
                this.listeners.push(this.renderer2.listen(accordionToggle.elementRef.nativeElement, 'click', (event) => {
                    this.toggleAccordion(event, accordionToggle.accordionComponent.index);
                    this.changeDetectorRef.detectChanges();
                }));
                this.listeners.push(this.renderer2.listen(accordionToggle.elementRef.nativeElement, 'mouseenter', () => {
                    AccordionGroupComponent_1.headerMouseEnter(accordionToggle.accordionComponent);
                    this.changeDetectorRef.detectChanges();
                }));
                this.listeners.push(this.renderer2.listen(accordionToggle.elementRef.nativeElement, 'mouseleave', () => {
                    AccordionGroupComponent_1.headerMouseLeave(accordionToggle.accordionComponent);
                    this.changeDetectorRef.detectChanges();
                }));
            });
        });
    }
    /**
     * [updateAccordionIsCollapsed description]
     * @method updateAccordionIsCollapsed
     */
    updateAccordionIsCollapsed() {
        this.accordionComponents.forEach((accordion, index) => {
            accordion.isCollapsed = this.activeIndex.indexOf(index) === -1;
        });
    }
};
AccordionGroupComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: Renderer2 }
];
__decorate([
    Input('activeIndex'),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], AccordionGroupComponent.prototype, "_activeIndex", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], AccordionGroupComponent.prototype, "isMultiple", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AccordionGroupComponent.prototype, "styleClass", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], AccordionGroupComponent.prototype, "collapseStart", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], AccordionGroupComponent.prototype, "collapseDone", void 0);
__decorate([
    ContentChildren(AccordionComponent),
    __metadata("design:type", QueryList)
], AccordionGroupComponent.prototype, "accordionComponents", void 0);
__decorate([
    ViewChildren(AccordionToggleDirective),
    __metadata("design:type", QueryList)
], AccordionGroupComponent.prototype, "accordionToggleDirectives", void 0);
AccordionGroupComponent = AccordionGroupComponent_1 = __decorate([
    Component({
        selector: 'mk-accordion-group',
        template: "<div [ngClass]=\"styleClass\">\n  <div *ngFor=\"let accordion of accordionComponents\" class=\"panel box\" [mkColor]=\"accordion.borderColor\" mkColorProperty=\"border-top-color\" mkColorPrefix=\"box\">\n    <div [ngClass]=\"accordion.headerStyleClass\" [class.no-border]=\"accordion.isCollapsed && !accordion.isCollapsing\">\n      <h4 class=\"box-title\">\n        <a [mkAccordionToggle]=\"accordion\" href=\"#\" [mkFontColor]=\"accordion.headerStyleColor\" [class.collapsed]=\"accordion.isCollapsed\">\n          {{accordion.header}}\n          <ng-template *ngIf=\"!accordion.header\" [ngTemplateOutlet]=\"accordion.accordionHeaderComponent?.templateRef\"></ng-template>\n        </a>\n      </h4>\n    </div>\n    <div class=\"panel-collapse\" [mkCollapseAnimation]=\"accordion.isCollapsed\" (mkCollapseAnimation.start)=\"onCollapseStart($event, accordion)\" (mkCollapseAnimation.done)=\"onCollapseDone($event, accordion)\">\n      <div [ngClass]=\"accordion.contentStyleClass\" [mkFontColor]=\"accordion.contentColor\">\n        <ng-template [ngTemplateOutlet]=\"accordion.contentTemplateRef\"></ng-template>\n      </div>\n    </div>\n  </div>\n</div>\n"
    }),
    __metadata("design:paramtypes", [ChangeDetectorRef,
        NgZone,
        Renderer2])
], AccordionGroupComponent);

let AccordionModule = class AccordionModule {
};
AccordionModule = __decorate([
    NgModule({
        imports: [CommonModule, AnimationsModule, ColorModule],
        exports: [AccordionHeaderComponent, AccordionContentComponent, AccordionComponent, AccordionGroupComponent],
        declarations: [AccordionToggleDirective, AccordionHeaderComponent,
            AccordionContentComponent, AccordionComponent, AccordionGroupComponent]
    })
], AccordionModule);

/*
 *
 */
let AlertComponent = class AlertComponent {
    /**
     * @method constructor
     * @param  changeDetectorRef [description]
     * @param  ngZone            [description]
     * @param  renderer2         [description]
     * @param  viewContainerRef  [description]
     */
    constructor(changeDetectorRef, ngZone, renderer2, viewContainerRef) {
        this.changeDetectorRef = changeDetectorRef;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.viewContainerRef = viewContainerRef;
        this.dismissibleClass = 'alert-dismissible';
        this.isDismissible = true;
        this.remove = false;
        this.type = 'alert';
        this.listeners = [];
        this.backgroundColor = 'danger';
        this.styleClass = '';
        this.collapseStart = new EventEmitter();
        this.collapseDone = new EventEmitter();
    }
    set callout(value) {
        this.type = value ? 'callout' : 'alert';
    }
    set _isDismissible(value) {
        this.isDismissible = value;
        if (value) {
            this.dismissibleClass = `${this.type}-dismissible`;
        }
        else {
            this.dismissibleClass = '';
        }
    }
    /**
     * @method ngOnInit
     */
    ngAfterViewInit() {
        this.ngZone.runOutsideAngular(() => {
            if (this.dismissOnTimeout) {
                setTimeout(() => {
                    if (!this.changeDetectorRef.destroyed) {
                        this.remove = true;
                        this.changeDetectorRef.detectChanges();
                    }
                }, this.dismissOnTimeout);
            }
            if (this.removeButtonElement) {
                this.listeners.push(this.renderer2.listen(this.removeButtonElement.nativeElement, 'click', () => {
                    this.remove = true;
                    this.changeDetectorRef.detectChanges();
                }));
            }
        });
    }
    /**
     * @method ngOnDesroy
     */
    ngOnDestroy() {
        removeListeners(this.listeners);
    }
    /**
     * [collapseStart description]
     * @method collapseStart
     * @param event [description]
     */
    onCollapseStart(event) {
        this.collapseStart.emit(event);
    }
    /**
     * [collapseDone description]
     * @method collapseDone
     * @param event [description]
     */
    onCollapseDone(event) {
        if (event.toState === '1') {
            this.listeners = removeListeners(this.listeners);
            this.removed = true;
            this.viewContainerRef.clear();
            this.changeDetectorRef.detectChanges();
        }
        this.collapseDone.emit(event);
    }
};
AlertComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: Renderer2 },
    { type: ViewContainerRef }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], AlertComponent.prototype, "backgroundColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], AlertComponent.prototype, "callout", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], AlertComponent.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], AlertComponent.prototype, "dismissOnTimeout", void 0);
__decorate([
    Input('isDismissible'),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], AlertComponent.prototype, "_isDismissible", null);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AlertComponent.prototype, "styleClass", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], AlertComponent.prototype, "collapseStart", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], AlertComponent.prototype, "collapseDone", void 0);
__decorate([
    ViewChild('removeButtonElement'),
    __metadata("design:type", ElementRef)
], AlertComponent.prototype, "removeButtonElement", void 0);
__decorate([
    ViewChild('containerElementRef', { read: ViewContainerRef }),
    __metadata("design:type", ViewContainerRef)
], AlertComponent.prototype, "containerElementRef", void 0);
AlertComponent = __decorate([
    Component({
        selector: 'mk-alert',
        template: "<div *ngIf=\"!removed\" [mkCollapseAnimation]=\"remove\" (mkCollapseAnimation.start)=\"onCollapseStart($event)\" (mkCollapseAnimation.done)=\"onCollapseDone($event)\">\n  <div [mkColor]=\"backgroundColor\" mkColorProperty=\"background-color\" [mkColorPrefix]=\"type\" [mkFontColor]=\"color\" [ngClass]=\"[styleClass, dismissibleClass, type]\">\n    <button *ngIf=\"isDismissible\" type=\"button\" class=\"close\" #removeButtonElement>&times;</button>\n    <ng-content></ng-content>\n  </div>\n</div>\n",
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: [".callout-dismissable,.callout-dismissible{padding-right:35px}.callout-dismissable .close,.callout-dismissible .close{position:relative;top:-2px;right:-21px;color:inherit}.callout .close{color:#000;opacity:.2}.callout .icon{margin-right:10px}"]
    }),
    __metadata("design:paramtypes", [ChangeDetectorRef,
        NgZone,
        Renderer2,
        ViewContainerRef])
], AlertComponent);

let AlertModule = class AlertModule {
};
AlertModule = __decorate([
    NgModule({
        imports: [CommonModule, AnimationsModule, ColorModule],
        exports: [AlertComponent],
        declarations: [AlertComponent]
    })
], AlertModule);

/*
 *
 */
let BoxContentDirective = class BoxContentDirective {
};
BoxContentDirective = __decorate([
    Directive({
        /* tslint:disable-next-line:directive-selector */
        selector: 'mk-box-content'
    })
], BoxContentDirective);
/*
 *
 */
let BoxFooterDirective = class BoxFooterDirective {
};
BoxFooterDirective = __decorate([
    Directive({
        /* tslint:disable-next-line:directive-selector */
        selector: 'mk-box-footer'
    })
], BoxFooterDirective);
/*
 *
 */
let BoxToolsDirective = class BoxToolsDirective {
};
BoxToolsDirective = __decorate([
    Directive({
        /* tslint:disable-next-line:directive-selector */
        selector: 'mk-box-tools'
    })
], BoxToolsDirective);
/*
 *
 */
let BoxHeaderDirective = class BoxHeaderDirective {
};
BoxHeaderDirective = __decorate([
    Directive({
        /* tslint:disable-next-line:directive-selector */
        selector: 'mk-box-header'
    })
], BoxHeaderDirective);

/*
 *
 */
let BoxComponent = class BoxComponent {
    /**
     * @method constructor
     * @param changeDetectorRef [description]
     * @param ngZone            [description]
     * @param renderer2         [description]
     */
    constructor(changeDetectorRef, ngZone, renderer2) {
        this.changeDetectorRef = changeDetectorRef;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.remove = false;
        this.listeners = [];
        this.boxColor = 'default';
        this.buttonsStyleClass = 'btn btn-box-tool';
        this.contentStyleClass = 'box-content-wrapper';
        this.footerStyleClass = 'box-footer';
        this.headerBorder = true;
        this.headerStyleClass = 'box-header';
        this.isCollapsable = true;
        this.isCollapsed = false;
        this.isRemovable = true;
        this.isSolid = false;
        this.loadingStyleClass = 'fa fa-refresh fa-spin';
        this.styleClass = 'box';
        this.collapseDone = new EventEmitter();
        this.collapseStart = new EventEmitter();
    }
    /**
     * @method ngAfterViewInit
     */
    ngAfterViewInit() {
        this.ngZone.runOutsideAngular(() => {
            if (this.toggleButtonElement) {
                this.listeners.push(this.renderer2.listen(this.toggleButtonElement.nativeElement, 'click', () => {
                    this.isCollapsed = !this.isCollapsed;
                    this.changeDetectorRef.detectChanges();
                }));
            }
            if (this.removeButtonElement) {
                this.listeners.push(this.renderer2.listen(this.removeButtonElement.nativeElement, 'click', () => {
                    this.remove = true;
                    this.changeDetectorRef.detectChanges();
                }));
            }
        });
    }
    /**
     * @method ngOnDestroy
     */
    ngOnDestroy() {
        removeListeners(this.listeners);
    }
    /**
     * [removedDone description]
     * @method removedDone
     * @param event [description]
     */
    removedDone(event) {
        if (event.toState === '1') {
            this.removed = true;
        }
    }
    /**
     * [collapseStart description]
     * @method collapseStart
     * @param event [description]
     */
    onCollapseStart(event) {
        if (event.fromState !== 'void') {
            this.isCollaping = true;
            this.collapseStart.emit(event);
        }
    }
    /**
     * [collapseDone description]
     * @method collapseDone
     * @param event [description]
     */
    onCollapseDone(event) {
        if (event.fromState !== 'void') {
            this.isCollaping = false;
            this.collapseDone.emit(event);
        }
    }
};
BoxComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], BoxComponent.prototype, "boxColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], BoxComponent.prototype, "buttonsStyleClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], BoxComponent.prototype, "contentStyleClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], BoxComponent.prototype, "contentColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], BoxComponent.prototype, "footer", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], BoxComponent.prototype, "footerColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], BoxComponent.prototype, "footerStyleClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], BoxComponent.prototype, "header", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], BoxComponent.prototype, "headerBorder", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], BoxComponent.prototype, "headerColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], BoxComponent.prototype, "headerStyleClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], BoxComponent.prototype, "isCollapsable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], BoxComponent.prototype, "isCollapsed", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], BoxComponent.prototype, "isLoading", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], BoxComponent.prototype, "isRemovable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], BoxComponent.prototype, "isSolid", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], BoxComponent.prototype, "loadingColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], BoxComponent.prototype, "loadingStyleClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], BoxComponent.prototype, "styleClass", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], BoxComponent.prototype, "collapseDone", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], BoxComponent.prototype, "collapseStart", void 0);
__decorate([
    ContentChild(BoxHeaderDirective, /* TODO: add static flag */ {}),
    __metadata("design:type", BoxHeaderDirective)
], BoxComponent.prototype, "boxHeaderDirective", void 0);
__decorate([
    ContentChild(BoxFooterDirective, /* TODO: add static flag */ {}),
    __metadata("design:type", BoxFooterDirective)
], BoxComponent.prototype, "boxFooterDirective", void 0);
__decorate([
    ContentChild(BoxContentDirective, /* TODO: add static flag */ {}),
    __metadata("design:type", BoxContentDirective)
], BoxComponent.prototype, "boxContentDirective", void 0);
__decorate([
    ContentChild(BoxToolsDirective, /* TODO: add static flag */ {}),
    __metadata("design:type", BoxToolsDirective)
], BoxComponent.prototype, "boxToolsDirective", void 0);
__decorate([
    ViewChild('toggleButtonElement'),
    __metadata("design:type", Object)
], BoxComponent.prototype, "toggleButtonElement", void 0);
__decorate([
    ViewChild('removeButtonElement'),
    __metadata("design:type", Object)
], BoxComponent.prototype, "removeButtonElement", void 0);
BoxComponent = __decorate([
    Component({
        selector: 'mk-box',
        template: "<div *ngIf=\"!removed\" [mkColor]=\"boxColor\" mkColorProperty=\"border-color\" mkColorPrefix=\"box\" [ngClass]=\"styleClass\" [class.collapsed-box]=\"isCollapsed && !isCollaping\" [class.box-solid]=\"isSolid\" [mkCollapseAnimation]=\"remove\" (mkCollapseAnimation.done)=\"removedDone($event)\">\n  <div *ngIf=\"header || boxHeaderDirective\" [ngClass]=\"headerStyleClass\" [mkColor]=\"boxColor\" [mkColorCondition]=\"isSolid\" mkColorProperty=\"background-color\" [class.with-border]=\"headerBorder\">\n    <h3 class=\"box-title\" [mkFontColor]=\"headerColor\">\n      {{header}}\n      <ng-content select=\"mk-box-header\"></ng-content>\n    </h3>\n    <div class=\"box-tools pull-right\">\n      <ng-content select=\"mk-box-tools\"></ng-content>\n      <button *ngIf=\"isCollapsable\" type=\"button\" [ngClass]=\"buttonsStyleClass\" #toggleButtonElement>\n        <i class=\"fa\" [ngClass]=\"{'fa-plus': isCollapsed, 'fa-minus': !isCollapsed}\"></i>\n      </button>\n      <button *ngIf=\"isRemovable\" type=\"button\" [ngClass]=\"buttonsStyleClass\" #removeButtonElement>\n        <i class=\"fa fa-times\"></i>\n      </button>\n    </div>\n  </div>\n  <div [ngClass]=\"contentStyleClass\" [mkFontColor]=\"contentColor\" [mkCollapseAnimation]=\"isCollapsed\" (mkCollapseAnimation.start)=\"onCollapseStart($event)\" (mkCollapseAnimation.done)=\"onCollapseDone($event)\">\n    <div class=\"box-body\">\n      <ng-container *ngIf=\"boxHeaderDirective || boxContentDirective || boxFooterDirective || boxToolsDirective; else noDirective\">\n        <ng-content select=\"mk-box-content\"></ng-content>\n      </ng-container>\n      <ng-template #noDirective>\n        <ng-content></ng-content>\n      </ng-template>\n    </div>\n    <div *ngIf=\"footer || boxFooterDirective\" [ngClass]=\"footerStyleClass\" [mkFontColor]=\"footerColor\">\n      {{footer}}\n      <ng-content select=\"mk-box-footer\"></ng-content>\n    </div>\n  </div>\n  <div *ngIf=\"isLoading\" class=\"overlay\">\n    <i [ngClass]=\"loadingStyleClass\" [mkFontColor]=\"loadingColor\"></i>\n  </div>\n</div>\n",
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: [".box.collapsed-box .box-body,.box.collapsed-box .box-footer{display:inherit}.box-solid{border:1px solid}.box-body{background-color:#fff}.box.box-solid.bg-color>.box-header{color:#fff}"]
    }),
    __metadata("design:paramtypes", [ChangeDetectorRef,
        NgZone,
        Renderer2])
], BoxComponent);

let BoxModule = class BoxModule {
};
BoxModule = __decorate([
    NgModule({
        imports: [CommonModule, AnimationsModule, ColorModule],
        exports: [BoxComponent, BoxHeaderDirective, BoxContentDirective, BoxFooterDirective, BoxToolsDirective],
        declarations: [BoxComponent, BoxHeaderDirective, BoxContentDirective, BoxFooterDirective, BoxToolsDirective]
    })
], BoxModule);

/*
 *
 */
let BoxInfoContentDirective = class BoxInfoContentDirective {
};
BoxInfoContentDirective = __decorate([
    Directive({
        /* tslint:disable-next-line:directive-selector */
        selector: 'mk-box-info-content'
    })
], BoxInfoContentDirective);
/*
 *
 */
let BoxInfoFooterDirective = class BoxInfoFooterDirective {
};
BoxInfoFooterDirective = __decorate([
    Directive({
        /* tslint:disable-next-line:directive-selector */
        selector: 'mk-box-info-footer'
    })
], BoxInfoFooterDirective);
/*
 *
 */
let BoxInfoHeaderDirective = class BoxInfoHeaderDirective {
};
BoxInfoHeaderDirective = __decorate([
    Directive({
        /* tslint:disable-next-line:directive-selector */
        selector: 'mk-box-info-header'
    })
], BoxInfoHeaderDirective);

/*
 *
 */
let BoxInfoComponent = class BoxInfoComponent {
    constructor() {
        this.contentStyleClass = 'info-box-number';
        this.footerStyleClass = 'progress-description';
        this.headerStyleClass = 'info-box-text';
        this.iconColor = '#fff';
        this.iconStyleClass = 'ion ion-bag';
        this.styleClass = 'info-box';
    }
    /**
     * @method ngOnInit
     */
    ngOnInit() {
        if (!this.backgroundColor) {
            this.progressBarBg = this.iconBackgroundColor;
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], BoxInfoComponent.prototype, "backgroundColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], BoxInfoComponent.prototype, "contentStyleClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], BoxInfoComponent.prototype, "contentColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], BoxInfoComponent.prototype, "footer", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], BoxInfoComponent.prototype, "footerColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], BoxInfoComponent.prototype, "footerStyleClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], BoxInfoComponent.prototype, "header", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], BoxInfoComponent.prototype, "headerColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], BoxInfoComponent.prototype, "headerStyleClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], BoxInfoComponent.prototype, "iconBackgroundColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], BoxInfoComponent.prototype, "iconColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], BoxInfoComponent.prototype, "iconStyleClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], BoxInfoComponent.prototype, "progressWidth", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], BoxInfoComponent.prototype, "styleClass", void 0);
__decorate([
    ContentChild(BoxInfoHeaderDirective, /* TODO: add static flag */ {}),
    __metadata("design:type", BoxInfoHeaderDirective)
], BoxInfoComponent.prototype, "boxInfoHeaderDirective", void 0);
__decorate([
    ContentChild(BoxInfoFooterDirective, /* TODO: add static flag */ {}),
    __metadata("design:type", BoxInfoFooterDirective)
], BoxInfoComponent.prototype, "boxInfoFooterDirective", void 0);
__decorate([
    ContentChild(BoxInfoContentDirective, /* TODO: add static flag */ {}),
    __metadata("design:type", BoxInfoContentDirective)
], BoxInfoComponent.prototype, "boxInfoContentDirective", void 0);
BoxInfoComponent = __decorate([
    Component({
        selector: 'mk-box-info',
        template: "<div [ngClass]=\"styleClass\" [mkColor]=\"backgroundColor\" mkColorProperty=\"background-color\">\n  <span class=\"info-box-icon\" [mkColor]=\"iconBackgroundColor\" mkColorProperty=\"background-color\">\n    <i [ngClass]=\"iconStyleClass\" [mkFontColor]=\"iconColor\"></i>\n  </span>\n  <div class=\"info-box-content\">\n    <span *ngIf=\"header || boxInfoHeaderDirective\" [ngClass]=\"headerStyleClass\" [mkFontColor]=\"headerColor\">\n      {{header}}\n      <ng-content select=\"mk-box-header\"></ng-content>\n    </span>\n    <span [ngClass]=\"contentStyleClass\" [mkFontColor]=\"contentColor\">\n      <ng-container *ngIf=\"boxInfoHeaderDirective || boxInfoContentDirective || boxInfoFooterDirective; else noDirective\">\n        <ng-content select=\"mk-box-content\"></ng-content>\n      </ng-container>\n      <ng-template #noDirective>\n        <ng-content></ng-content>\n      </ng-template>\n    </span>\n    <div *ngIf=\"progressWidth\" class=\"progress\">\n      <div class=\"progress-bar\" [mkColor]=\"progressBarBg\" mkColorProperty=\"background-color\" [style.width.%]=\"progressWidth\"></div>\n    </div>\n    <span *ngIf=\"footer || boxInfoFooterDirective\" [ngClass]=\"footerStyleClass\" [mkFontColor]=\"footerColor\">\n      {{footer}}\n      <ng-content select=\"mk-box-footer\"></ng-content>\n    </span>\n  </div>\n</div>\n",
        styles: [".info-box.bg-color>.info-box-content{color:#fff}"]
    })
], BoxInfoComponent);

let BoxInfoModule = class BoxInfoModule {
};
BoxInfoModule = __decorate([
    NgModule({
        imports: [CommonModule, ColorModule],
        exports: [BoxInfoComponent, BoxInfoHeaderDirective, BoxInfoContentDirective, BoxInfoFooterDirective],
        declarations: [BoxInfoComponent, BoxInfoHeaderDirective, BoxInfoContentDirective, BoxInfoFooterDirective]
    })
], BoxInfoModule);

/*
 *
 */
let BoxSmallFooterDirective = class BoxSmallFooterDirective {
};
BoxSmallFooterDirective = __decorate([
    Directive({
        /* tslint:disable-next-line:directive-selector */
        selector: 'mk-box-small-footer'
    })
], BoxSmallFooterDirective);
/*
 *
 */
let BoxSmallHeaderDirective = class BoxSmallHeaderDirective {
};
BoxSmallHeaderDirective = __decorate([
    Directive({
        /* tslint:disable-next-line:directive-selector */
        selector: 'mk-box-small-header'
    })
], BoxSmallHeaderDirective);
/*
 *
 */
let BoxSmallContentDirective = class BoxSmallContentDirective {
};
BoxSmallContentDirective = __decorate([
    Directive({
        /* tslint:disable-next-line:directive-selector */
        selector: 'mk-box-small-content'
    })
], BoxSmallContentDirective);

/*
 *
 */
let BoxSmallComponent = class BoxSmallComponent {
    constructor() {
        this.contentStyleClass = 'small-box-content';
        this.footerStyleClass = 'small-box-footer';
        this.headerStyleClass = 'small-box-header';
        this.iconStyleClass = 'ion ion-bag';
        this.styleClass = 'small-box';
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], BoxSmallComponent.prototype, "backgroundColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], BoxSmallComponent.prototype, "contentColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], BoxSmallComponent.prototype, "contentStyleClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], BoxSmallComponent.prototype, "footer", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], BoxSmallComponent.prototype, "footerColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], BoxSmallComponent.prototype, "footerStyleClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], BoxSmallComponent.prototype, "header", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], BoxSmallComponent.prototype, "headerColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], BoxSmallComponent.prototype, "headerStyleClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], BoxSmallComponent.prototype, "iconColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], BoxSmallComponent.prototype, "iconStyleClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], BoxSmallComponent.prototype, "styleClass", void 0);
__decorate([
    ContentChild(BoxSmallHeaderDirective, /* TODO: add static flag */ {}),
    __metadata("design:type", BoxSmallHeaderDirective)
], BoxSmallComponent.prototype, "boxSmallHeaderDirective", void 0);
__decorate([
    ContentChild(BoxSmallFooterDirective, /* TODO: add static flag */ {}),
    __metadata("design:type", BoxSmallFooterDirective)
], BoxSmallComponent.prototype, "boxSmallFooterDirective", void 0);
__decorate([
    ContentChild(BoxSmallContentDirective, /* TODO: add static flag */ {}),
    __metadata("design:type", BoxSmallContentDirective)
], BoxSmallComponent.prototype, "boxSmallContentDirective", void 0);
BoxSmallComponent = __decorate([
    Component({
        selector: 'mk-box-small',
        template: "<div [ngClass]=\"styleClass\" [mkColor]=\"backgroundColor\" mkColorProperty=\"background-color\">\n  <div class=\"inner\">\n    <h3 *ngIf=\"header || boxSmallHeaderDirective\" [ngClass]=\"headerStyleClass\" [mkFontColor]=\"headerColor\">\n      {{header}}\n      <ng-content select=\"mk-box-small-header\"></ng-content>\n    </h3>\n    <p [ngClass]=\"contentStyleClass\" [mkFontColor]=\"contentColor\">\n      <ng-container *ngIf=\"boxSmallHeaderDirective || boxSmallContentDirective || boxSmallFooterDirective; else noDirective\">\n        <ng-content select=\"mk-box-small-content\"></ng-content>\n      </ng-container>\n      <ng-template #noDirective>\n        <ng-content></ng-content>\n      </ng-template>\n    </p>\n  </div>\n  <div *ngIf=\"iconStyleClass\" class=\"icon\">\n    <i [ngClass]=\"iconStyleClass\" [mkFontColor]=\"iconColor\"></i>\n  </div>\n  <span *ngIf=\"footer || boxSmallFooterDirective\" [ngClass]=\"footerStyleClass\" [mkFontColor]=\"footerColor\">\n    {{footer}}\n    <ng-content select=\"mk-box-small-footer\"></ng-content>\n  </span>\n</div>\n",
        styles: [".small-box.bg-color{color:#fff}/deep/ .small-box-footer:hover{cursor:pointer}/deep/ .small-box-footer a{color:rgba(255,255,255,.8)}/deep/ .small-box-footer:hover a{color:#fff}"]
    })
], BoxSmallComponent);

let BoxSmallModule = class BoxSmallModule {
};
BoxSmallModule = __decorate([
    NgModule({
        imports: [CommonModule, ColorModule],
        exports: [BoxSmallComponent, BoxSmallHeaderDirective, BoxSmallContentDirective, BoxSmallFooterDirective],
        declarations: [BoxSmallComponent, BoxSmallHeaderDirective, BoxSmallContentDirective, BoxSmallFooterDirective]
    })
], BoxSmallModule);

/*
 *
 */
let DropdownToggleComponent = class DropdownToggleComponent {
};
__decorate([
    ViewChild('templateRef', { static: true }),
    __metadata("design:type", TemplateRef)
], DropdownToggleComponent.prototype, "templateRef", void 0);
__decorate([
    ContentChild('toggleElement', /* TODO: add static flag */ {}),
    __metadata("design:type", ElementRef)
], DropdownToggleComponent.prototype, "toggleElement", void 0);
DropdownToggleComponent = __decorate([
    Component({
        selector: 'mk-dropdown-toggle',
        template: '<ng-template #templateRef><ng-content></ng-content></ng-template>',
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], DropdownToggleComponent);
/*
 *
 */
let DropdownMenuComponent = class DropdownMenuComponent {
};
__decorate([
    ViewChild('templateRef', { static: true }),
    __metadata("design:type", TemplateRef)
], DropdownMenuComponent.prototype, "templateRef", void 0);
DropdownMenuComponent = __decorate([
    Component({
        selector: 'mk-dropdown-menu',
        template: '<ng-template #templateRef><ng-content></ng-content></ng-template>',
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], DropdownMenuComponent);
/*
 *
 */
let DropdownComponent = class DropdownComponent {
    /**
     * @method constructor
     * @param changeDetectorRef [description]
     * @param elementRef [description]
     * @param ngZone [description]
     * @param renderer2 [description]
     */
    constructor(changeDetectorRef, elementRef, ngZone, renderer2) {
        this.changeDetectorRef = changeDetectorRef;
        this.elementRef = elementRef;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.listeners = [];
        this.buttonStyleClass = 'btn dropdown-toggle';
        this.buttonBackgroudColor = 'default';
        this.contentStyleClass = 'dropdown-menu';
        this.isCollapsed = true;
        this.isWrapper = true;
        this.styleClass = 'dropdown';
        this.collapseStart = new EventEmitter();
        this.collapseDone = new EventEmitter();
    }
    /**
     * @method ngAfterViewInit
     */
    ngAfterViewInit() {
        const toggleNativeElement = this.dropdownToggleComponent && this.dropdownToggleComponent.toggleElement ?
            this.dropdownToggleComponent.toggleElement.nativeElement : this.toggleElement ?
            this.toggleElement : this.defaultToggleElement ?
            this.defaultToggleElement.nativeElement : null;
        if (toggleNativeElement) {
            this.ngZone.runOutsideAngular(() => {
                this.listeners.push(this.renderer2.listen(toggleNativeElement, 'click', (event) => {
                    this.toggleDropdown(event);
                    this.changeDetectorRef.detectChanges();
                }));
            });
        }
    }
    /**
     * @method ngOnDestroy
     */
    ngOnDestroy() {
        this.unBindDocumentClickListener();
        removeListeners(this.listeners);
    }
    /**
     * [toggle description]
     * @method toggle
     * @param event [description]
     */
    toggleDropdown(event) {
        event.preventDefault();
        this.isCollapsed = !this.isCollapsed;
        if (!this.isCollapsed) {
            this.ngZone.runOutsideAngular(() => {
                setTimeout(() => {
                    this.bindDocumentClickListener();
                });
            });
        }
        else {
            this.unBindDocumentClickListener();
        }
    }
    /**
     * [collapseStart description]
     * @method collapseStart
     * @param event [description]
     */
    onCollapseStart(event) {
        this.collapseStart.emit(event);
    }
    /**
     * [collapseDone description]
     * @method collapseDone
     * @param event [description]
     */
    onCollapseDone(event) {
        this.collapseStart.emit(event);
    }
    /**
     * [bindDocumentClickListener description]
     * @method bindDocumentClickListener
     */
    bindDocumentClickListener() {
        this.ngZone.runOutsideAngular(() => {
            this.documentClickListener = this.renderer2.listen('document', 'click', () => {
                if (!this.isCollapsed) {
                    this.isCollapsed = true;
                    this.unBindDocumentClickListener();
                    this.changeDetectorRef.detectChanges();
                }
            });
        });
    }
    /**
     * [unBindDocumentClickListener description]
     * @method unBindDocumentClickListener
     */
    unBindDocumentClickListener() {
        if (this.documentClickListener) {
            this.documentClickListener();
        }
    }
};
DropdownComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], DropdownComponent.prototype, "buttonStyleClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DropdownComponent.prototype, "buttonBackgroudColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DropdownComponent.prototype, "contentStyleClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DropdownComponent.prototype, "isCollapsed", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DropdownComponent.prototype, "isWrapper", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DropdownComponent.prototype, "styleClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Element)
], DropdownComponent.prototype, "toggleElement", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DropdownComponent.prototype, "toggleText", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], DropdownComponent.prototype, "collapseStart", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], DropdownComponent.prototype, "collapseDone", void 0);
__decorate([
    ContentChild(DropdownToggleComponent, /* TODO: add static flag */ {}),
    __metadata("design:type", DropdownToggleComponent)
], DropdownComponent.prototype, "dropdownToggleComponent", void 0);
__decorate([
    ContentChild(DropdownMenuComponent, /* TODO: add static flag */ {}),
    __metadata("design:type", DropdownMenuComponent)
], DropdownComponent.prototype, "dropdownMenuComponent", void 0);
__decorate([
    ViewChild('toggleElement'),
    __metadata("design:type", ElementRef)
], DropdownComponent.prototype, "defaultToggleElement", void 0);
DropdownComponent = __decorate([
    Component({
        selector: 'mk-dropdown, [mk-dropdown]',
        template: "<ng-template #innerTemplate>\n  <ng-container *ngIf=\"this.dropdownToggleComponent && this.dropdownToggleComponent.toggleElement; else noToggleElement\" [ngTemplateOutlet]=\"dropdownToggleComponent.templateRef\"></ng-container>\n  <ng-template #noToggleElement>\n    <button *ngIf=\"toggleText || dropdownToggleComponent\" [mkColor]=\"buttonBackgroudColor\" mkColorProperty=\"background-color\" mkColorPrefix=\"btn\" [ngClass]=\"buttonStyleClass\" #toggleElement>\n      {{toggleText}}\n      <ng-container [ngTemplateOutlet]=\"dropdownToggleComponent?.templateRef\"></ng-container>\n    </button>\n  </ng-template>\n  <ul [ngClass]=\"contentStyleClass\" [mkCollapseAnimation]=\"isCollapsed\" (mkCollapseAnimation.start)=\"onCollapseStart($event)\" (mkCollapseAnimation.done)=\"onCollapseDone($event)\">\n    <ng-container *ngIf=\"dropdownMenuComponent; else noDropdownMenuComponent\" [ngTemplateOutlet]=\"dropdownMenuComponent.templateRef\"></ng-container>\n    <ng-template #noDropdownMenuComponent>\n      <ng-content></ng-content>\n    </ng-template>\n  </ul>\n</ng-template>\n\n<div *ngIf=\"isWrapper; else noWrapper\" [ngClass]=\"styleClass\">\n  <ng-container *ngTemplateOutlet=\"innerTemplate\"></ng-container>\n</div>\n\n<ng-template #noWrapper>\n  <ng-container *ngTemplateOutlet=\"innerTemplate\"></ng-container>\n</ng-template>\n",
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: [".dropdown-menu{display:block}.dropdown-menu.collapsing:not(.un-collapse){transition-property:height,padding-top,padding-bottom;padding-top:0;padding-bottom:0}"]
    }),
    __metadata("design:paramtypes", [ChangeDetectorRef,
        ElementRef,
        NgZone,
        Renderer2])
], DropdownComponent);

let DropdownModule = class DropdownModule {
};
DropdownModule = __decorate([
    NgModule({
        imports: [CommonModule, AnimationsModule, ColorModule],
        exports: [DropdownComponent, DropdownToggleComponent, DropdownMenuComponent],
        declarations: [DropdownComponent, DropdownToggleComponent, DropdownMenuComponent]
    })
], DropdownModule);

/*
 *
 */
let InputGroupLabelDirective = class InputGroupLabelDirective {
};
InputGroupLabelDirective = __decorate([
    Directive({
        /* tslint:disable-next-line:directive-selector */
        selector: 'mk-input-group-label'
    })
], InputGroupLabelDirective);
/*
 *
 */
let InputGroupAddonLeftDirective = class InputGroupAddonLeftDirective {
};
InputGroupAddonLeftDirective = __decorate([
    Directive({
        /* tslint:disable-next-line:directive-selector */
        selector: 'mk-input-group-addon-left'
    })
], InputGroupAddonLeftDirective);
/*
 *
 */
let InputGroupAddonRightDirective = class InputGroupAddonRightDirective {
};
InputGroupAddonRightDirective = __decorate([
    Directive({
        /* tslint:disable-next-line:directive-selector */
        selector: 'mk-input-group-addon-right'
    })
], InputGroupAddonRightDirective);
/*
 *
 */
let InputGroupContentDirective = class InputGroupContentDirective {
};
InputGroupContentDirective = __decorate([
    Directive({
        /* tslint:disable-next-line:directive-selector */
        selector: 'mk-input-group-content'
    })
], InputGroupContentDirective);

/*
 *
 */
let ClassService = class ClassService {
    constructor(elementRef, renderer2) {
        this.elementRef = elementRef;
        this.renderer2 = renderer2;
        this.currentClasses = [];
    }
    applyClasses(cssClasses) {
        if (typeof cssClasses === 'string') {
            cssClasses = cssClasses.split(' ');
        }
        // Remove only classes that are not in cssClasses
        const classesToRemove = this.currentClasses.filter(x => cssClasses.indexOf(x) === -1);
        classesToRemove.forEach(cssClasse => {
            if (cssClasse) {
                this.renderer2.removeClass(this.elementRef.nativeElement, cssClasse);
            }
        });
        // Add only classes that are not in currentClasses
        const classesToAdd = cssClasses.filter(x => this.currentClasses.indexOf(x) === -1);
        classesToAdd.forEach(cssClasse => {
            if (cssClasse) {
                this.renderer2.addClass(this.elementRef.nativeElement, cssClasse);
            }
        });
        // Update current classes for futur updates
        this.currentClasses = [...cssClasses];
    }
};
ClassService.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
ClassService = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [ElementRef,
        Renderer2])
], ClassService);

// @TODO onFocus Color
let InputTextDirective = class InputTextDirective {
    /**
     * @method constructor
     * @param  elementRef   [description]
     * @param  renderer2    [description]
     * @param  ngControl    [description]
     * @param  colorService [description]
     * @param  classService [description]
     */
    constructor(elementRef, renderer2, ngControl, colorService, classService) {
        this.elementRef = elementRef;
        this.renderer2 = renderer2;
        this.ngControl = ngControl;
        this.colorService = colorService;
        this.classService = classService;
        this.defaultClass = 'form-control';
        this.onKeyUp = new Subject();
        this.onKeyup = this.onKeyUp.asObservable();
    }
    set borderColor(color) {
        this.colorService.setBackgroundColor(color, true, 'border-color', null);
    }
    set class(className) {
        this.isSetClass = true;
        this.classService.applyClasses(className);
    }
    set color(color) {
        this.colorService.setFontColor(color);
    }
    /**
     * @method ngOnInit
     */
    ngOnInit() {
        if (!this.isSetClass) {
            this.classService.applyClasses(this.defaultClass);
        }
    }
    keyUpListener() {
        this.onKeyUp.next(this.ngControl);
    }
};
InputTextDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgControl },
    { type: ColorService },
    { type: ClassService }
];
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], InputTextDirective.prototype, "borderColor", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], InputTextDirective.prototype, "class", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], InputTextDirective.prototype, "color", null);
__decorate([
    HostListener('keyup'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], InputTextDirective.prototype, "keyUpListener", null);
InputTextDirective = __decorate([
    Directive({
        selector: '[mkInputText]',
        providers: [ColorService, ClassService]
    }),
    __metadata("design:paramtypes", [ElementRef,
        Renderer2,
        NgControl,
        ColorService,
        ClassService])
], InputTextDirective);

/*
 *
 */
let InputGroupComponent = class InputGroupComponent {
    constructor() {
        this.subscriptions = [];
        this.inputColor = 'default';
        this.inputErrorColor = 'danger';
        this.inputValidColor = 'success';
        this.wrapperClasses = 'form-group';
    }
    ngAfterContentInit() {
        this.subscriptions.push(this.inputTextDirective.onKeyup.subscribe((value) => {
            if (value.invalid) {
                this.currentColor = this.inputErrorColor;
                this.currentFontColor = this.inputErrorFontColor;
            }
            else if (!value.invalid) {
                this.currentColor = this.inputValidColor;
                this.currentFontColor = this.inputValidFontColor;
            }
            else {
                this.currentColor = this.inputColor;
                this.currentFontColor = this.inputFontColor;
            }
        }));
    }
    ngOnDestroy() {
        removeSubscriptions(this.subscriptions);
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], InputGroupComponent.prototype, "addonLeft", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], InputGroupComponent.prototype, "addonRight", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], InputGroupComponent.prototype, "inputColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], InputGroupComponent.prototype, "inputFontColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], InputGroupComponent.prototype, "inputErrorColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], InputGroupComponent.prototype, "inputErrorFontColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], InputGroupComponent.prototype, "inputValidColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], InputGroupComponent.prototype, "inputValidFontColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], InputGroupComponent.prototype, "label", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], InputGroupComponent.prototype, "wrapperClasses", void 0);
__decorate([
    ContentChild(InputGroupLabelDirective),
    __metadata("design:type", InputGroupLabelDirective)
], InputGroupComponent.prototype, "inputGroupLabelDirective", void 0);
__decorate([
    ContentChild(InputGroupAddonLeftDirective),
    __metadata("design:type", InputGroupAddonLeftDirective)
], InputGroupComponent.prototype, "inputGroupAddonLeftDirective", void 0);
__decorate([
    ContentChild(InputGroupAddonRightDirective),
    __metadata("design:type", InputGroupAddonRightDirective)
], InputGroupComponent.prototype, "inputGroupAddonRightDirective", void 0);
__decorate([
    ContentChild(InputGroupContentDirective),
    __metadata("design:type", InputGroupContentDirective)
], InputGroupComponent.prototype, "inputGroupContentDirective", void 0);
__decorate([
    ContentChild(InputTextDirective),
    __metadata("design:type", InputTextDirective)
], InputGroupComponent.prototype, "inputTextDirective", void 0);
InputGroupComponent = __decorate([
    Component({
        selector: 'mk-input-group',
        template: "<div [ngClass]=\"wrapperClasses\" [mkColor]=\"currentColor || inputColor\" mkColorPrefix=\"has\">\n  <label *ngIf=\"label || inputGroupLabelDirective\">\n    {{label}}\n    <ng-content select=\"mk-input-group-label\"></ng-content>\n  </label>\n  <div *ngIf=\"addonLeft || inputGroupAddonLeftDirective || addonRight || inputGroupAddonRightDirective; else noAddon\" class=\"input-group\">\n    <span *ngIf=\"addonLeft || inputGroupAddonLeftDirective\" class=\"input-group-addon\">\n      {{addonLeft}}\n      <ng-content select=\"mk-input-group-addon-left\"></ng-content>\n    </span>\n    <ng-content select=\"mk-input-group-content\"></ng-content>\n    <span *ngIf=\"addonRight || inputGroupAddonRightDirective\" class=\"input-group-addon\">\n      {{addonRight}}\n      <ng-content select=\"mk-input-group-addon-right\"></ng-content>\n    </span>\n  </div>\n  <ng-template #noAddon><ng-content select=\"mk-input-group-content\"></ng-content></ng-template>\n</div>\n"
    })
], InputGroupComponent);

let InputGroupModule = class InputGroupModule {
};
InputGroupModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            ColorModule,
            FormsModule
        ],
        exports: [InputGroupComponent, InputGroupLabelDirective, InputGroupAddonLeftDirective,
            InputGroupAddonRightDirective, InputGroupContentDirective],
        declarations: [InputGroupComponent, InputGroupLabelDirective, InputGroupAddonLeftDirective,
            InputGroupAddonRightDirective, InputGroupContentDirective]
    })
], InputGroupModule);

let InputTextModule = class InputTextModule {
};
InputTextModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            ColorModule,
            FormsModule
        ],
        exports: [InputTextDirective],
        declarations: [InputTextDirective]
    })
], InputTextModule);

/*
 *
 */
let TabToggleDirective = class TabToggleDirective {
    /**
     * @method constructor
     * @param elementRef [description]
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
};
TabToggleDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input('mkTabToggle'),
    __metadata("design:type", Object)
], TabToggleDirective.prototype, "tabComponent", void 0);
TabToggleDirective = __decorate([
    Directive({
        selector: '[mkTabToggle]'
    }),
    __metadata("design:paramtypes", [ElementRef])
], TabToggleDirective);

// @TODO Vertical tabs
/*
 *
 */
let TabHeaderComponent = class TabHeaderComponent {
};
__decorate([
    ViewChild('templateRef', { static: true }),
    __metadata("design:type", TemplateRef)
], TabHeaderComponent.prototype, "templateRef", void 0);
TabHeaderComponent = __decorate([
    Component({
        selector: 'mk-tab-header',
        template: '<ng-template #templateRef><ng-content></ng-content></ng-template>',
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], TabHeaderComponent);
/*
 *
 */
let TabContentComponent = class TabContentComponent {
};
__decorate([
    ViewChild('templateRef', { static: true }),
    __metadata("design:type", TemplateRef)
], TabContentComponent.prototype, "templateRef", void 0);
TabContentComponent = __decorate([
    Component({
        selector: 'mk-tab-content',
        template: '<ng-template #templateRef><ng-content></ng-content></ng-template>',
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], TabContentComponent);
/*
 *
 */
let TabComponent = class TabComponent {
    constructor() {
        this.isActive = false;
    }
    /**
     * @method ngOnInit
     */
    ngAfterContentInit() {
        if (this.tabContentComponent) {
            this.contentTemplateRef = this.tabContentComponent.templateRef;
        }
        else {
            this.contentTemplateRef = this.templateRef;
        }
    }
};
__decorate([
    Input(),
    __metadata("design:type", String)
], TabComponent.prototype, "header", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TabComponent.prototype, "isDisabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TabComponent.prototype, "tabColor", void 0);
__decorate([
    ViewChild('templateRef', { static: true }),
    __metadata("design:type", TemplateRef)
], TabComponent.prototype, "templateRef", void 0);
__decorate([
    ContentChild(TabHeaderComponent),
    __metadata("design:type", TabHeaderComponent)
], TabComponent.prototype, "tabHeaderComponent", void 0);
__decorate([
    ContentChild(TabContentComponent),
    __metadata("design:type", TabContentComponent)
], TabComponent.prototype, "tabContentComponent", void 0);
TabComponent = __decorate([
    Component({
        selector: 'mk-tab',
        template: '<ng-template #templateRef><ng-content></ng-content></ng-template>',
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], TabComponent);
/*
 *
 */
let TabsHeaderComponent = class TabsHeaderComponent {
};
__decorate([
    ViewChild('templateRef', { static: true }),
    __metadata("design:type", TemplateRef)
], TabsHeaderComponent.prototype, "templateRef", void 0);
TabsHeaderComponent = __decorate([
    Component({
        selector: 'mk-tabs-header',
        template: '<ng-template #templateRef><ng-content></ng-content></ng-template>',
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], TabsHeaderComponent);
/*
 *
 */
let TabsComponent = class TabsComponent {
    /**
     * @method constructor
     * @param changeDetectorRef [description]
     * @param ngZone            [description]
     * @param renderer2         [description]
     */
    constructor(changeDetectorRef, ngZone, renderer2) {
        this.changeDetectorRef = changeDetectorRef;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.listeners = [];
        this.subscriptions = [];
        this.headerStyleClass = 'header pull-left';
        this.navStyleClass = 'nav nav-tabs';
        this.contentStyleClass = 'tab-content';
        this.styleClass = 'nav-tabs-custom';
        this.closeTab = new EventEmitter();
        this.openTab = new EventEmitter();
    }
    set activeTabIndex(index) {
        this.activatedTabIndex = index;
        this.changeDetectorRef.detectChanges();
    }
    /**
     * @method ngAfterViewInit
     */
    ngAfterContentInit() {
        // Set tab index on load.
        this.setTabIndex();
        // Update tab index if tabs is updated.
        this.subscriptions.push(this.tabs.changes.subscribe(() => {
            this.setTabIndex();
        }));
        // Open tab on load.
        this.openTabIndex();
    }
    /**
     * @method ngAfterViewInit
     */
    ngAfterViewInit() {
        // Set tab toggles on load.
        this.setTabsToggle();
        // Update tab toggles if tabs is updated.
        this.subscriptions.push(this.tabToggleDirectives.changes.subscribe(() => {
            this.setTabsToggle();
        }));
    }
    /**
     * @method ngOnChanges
     * @param changes [description]
     */
    ngOnChanges(changes) {
        if (changes.activeTabIndex) {
            this.openTabIndex();
        }
    }
    /**
     * @method ngOnDestroy
     */
    ngOnDestroy() {
        removeListeners(this.listeners);
        removeSubscriptions(this.subscriptions);
    }
    /**
     * [toggleTab description]
     * @method toggleTab
     */
    openTabIndex() {
        if (this.tabs) {
            this.tabs.forEach((tab) => {
                if (this.activatedTabIndex === tab.index || (this.activatedTabIndex === undefined && tab.index === 0)) {
                    tab.isActive = true;
                    this.openTab.emit({ index: tab.index });
                    this.changeDetectorRef.detectChanges();
                }
                else if (tab.isActive) {
                    tab.isActive = false;
                    this.closeTab.emit({ index: tab.index });
                    this.changeDetectorRef.detectChanges();
                }
            });
        }
    }
    /**
     * [openTab description]
     * @method openTab
     * @param event     [description]
     * @param tabToOpen [description]
     */
    onOpenTab(event, tabToOpen) {
        event.preventDefault();
        tabToOpen.isActive = true;
        this.openTab.emit({ event, index: tabToOpen.index });
        this.tabs.forEach((tab) => {
            if (tab.isActive && tabToOpen !== tab) {
                tab.isActive = false;
                this.closeTab.emit({ event, index: tab.index });
            }
        });
    }
    /**
     * [setTabIndex description]
     * @method setTabIndex
     */
    setTabIndex() {
        this.tabs.forEach((tab, index) => {
            tab.index = index;
        });
        this.changeDetectorRef.detectChanges();
    }
    /**
     * [setTabsToggle description]
     * @method setTabsToggle
     */
    setTabsToggle() {
        this.listeners = removeListeners(this.listeners);
        this.ngZone.runOutsideAngular(() => {
            this.tabToggleDirectives.forEach((tabToggle) => {
                this.listeners.push(this.renderer2.listen(tabToggle.elementRef.nativeElement, 'click', (event) => {
                    this.onOpenTab(event, tabToggle.tabComponent);
                    this.changeDetectorRef.detectChanges();
                }));
            });
        });
    }
};
TabsComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: Renderer2 }
];
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], TabsComponent.prototype, "activeTabIndex", null);
__decorate([
    Input(),
    __metadata("design:type", String)
], TabsComponent.prototype, "header", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TabsComponent.prototype, "headerStyleClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TabsComponent.prototype, "navStyleClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TabsComponent.prototype, "contentStyleClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TabsComponent.prototype, "styleClass", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TabsComponent.prototype, "tabsColor", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], TabsComponent.prototype, "closeTab", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], TabsComponent.prototype, "openTab", void 0);
__decorate([
    ContentChild(TabsHeaderComponent, { static: true }),
    __metadata("design:type", TabsHeaderComponent)
], TabsComponent.prototype, "tabsHeaderComponent", void 0);
__decorate([
    ContentChildren(TabComponent),
    __metadata("design:type", QueryList)
], TabsComponent.prototype, "tabs", void 0);
__decorate([
    ViewChildren(TabToggleDirective),
    __metadata("design:type", QueryList)
], TabsComponent.prototype, "tabToggleDirectives", void 0);
TabsComponent = __decorate([
    Component({
        selector: 'mk-tabs',
        template: "<div [ngClass]=\"styleClass\">\n  <ul [ngClass]=\"navStyleClass\" [class.pull-right]=\"header || tabsHeaderComponent\">\n    <li *ngFor=\"let tab of tabs\" [class.active]=\"tab.isActive\" [mkColor]=\"tab.tabColor || tabsColor\" mkColorProperty=\"border-top-color\">\n      <a *ngIf=\"!tab.isDisabled\" [mkTabToggle]=\"tab\" href=\"#\">\n        {{tab.header}}\n        <ng-template *ngIf=\"!tab.header\" [ngTemplateOutlet]=\"tab.tabHeaderComponent?.templateRef\"></ng-template>\n      </a>\n      <ng-template [ngIf]=\"tab.isDisabled\">\n        {{tab.header}}\n        <ng-template *ngIf=\"!tab.header\" [ngTemplateOutlet]=\"tab.tabHeaderComponent.templateRef\"></ng-template>\n      </ng-template>\n    </li>\n    <li *ngIf=\"tabsHeaderComponent || header\" [ngClass]=\"headerStyleClass\">\n      {{header}}\n      <ng-template *ngIf=\"!header\" [ngTemplateOutlet]=\"tabsHeaderComponent.templateRef\"></ng-template>\n    </li>\n  </ul>\n  <div [ngClass]=\"contentStyleClass\">\n    <div *ngFor=\"let tab of tabs\" class=\"tab-pane\" [class.active]=\"tab.isActive\">\n      <ng-template [ngTemplateOutlet]=\"tab.contentTemplateRef\"></ng-template>\n    </div>\n  </div>\n</div>\n",
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: [".nav-tabs-custom>.nav-tabs>li{border-top-width:0}.nav-tabs-custom>.nav-tabs>li.active{border-top-width:3px}"]
    }),
    __metadata("design:paramtypes", [ChangeDetectorRef,
        NgZone,
        Renderer2])
], TabsComponent);

let TabsModule = class TabsModule {
};
TabsModule = __decorate([
    NgModule({
        imports: [CommonModule, ColorModule],
        exports: [TabsComponent, TabsHeaderComponent, TabComponent, TabHeaderComponent, TabContentComponent],
        declarations: [TabToggleDirective, TabsComponent, TabsHeaderComponent, TabComponent, TabHeaderComponent, TabContentComponent]
    })
], TabsModule);

/*
 * Public API Surface of angular-admin-lte
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AccordionModule, AlertModule, BoxInfoModule, BoxModule, BoxSmallModule, BreadcrumbsModule, DropdownModule, InputGroupModule, InputTextModule, LayoutModule, LayoutService, LayoutStore, TabsModule, ContentModule as ɵa, BreadcrumbsComponent as ɵb, layoutStoreFactory as ɵba, layoutProvider as ɵbb, ColorModule as ɵbc, BackgroundColorDirective as ɵbd, ColorDirective as ɵbe, ColorService as ɵbf, AccordionHeaderComponent as ɵbg, AccordionContentComponent as ɵbh, AccordionComponent as ɵbi, AccordionGroupComponent as ɵbj, AccordionToggleDirective as ɵbk, AlertComponent as ɵbl, BoxComponent as ɵbm, BoxContentDirective as ɵbn, BoxFooterDirective as ɵbo, BoxToolsDirective as ɵbp, BoxHeaderDirective as ɵbq, BoxInfoComponent as ɵbr, BoxInfoContentDirective as ɵbs, BoxInfoFooterDirective as ɵbt, BoxInfoHeaderDirective as ɵbu, BoxSmallComponent as ɵbv, BoxSmallFooterDirective as ɵbw, BoxSmallHeaderDirective as ɵbx, BoxSmallContentDirective as ɵby, DropdownToggleComponent as ɵbz, RoutingService as ɵc, DropdownMenuComponent as ɵca, DropdownComponent as ɵcb, InputGroupComponent as ɵcc, InputGroupLabelDirective as ɵcd, InputGroupAddonLeftDirective as ɵce, InputGroupAddonRightDirective as ɵcf, InputGroupContentDirective as ɵcg, InputTextDirective as ɵch, ClassService as ɵci, TabHeaderComponent as ɵcj, TabContentComponent as ɵck, TabComponent as ɵcl, TabsHeaderComponent as ɵcm, TabsComponent as ɵcn, TabToggleDirective as ɵco, ContentComponent as ɵd, SidebarRightService as ɵe, HeaderService as ɵf, FooterService as ɵg, FooterModule as ɵh, FooterLeftComponent as ɵi, FooterRightComponent as ɵj, FooterComponent as ɵk, HeaderModule as ɵl, HeaderLogoComponent as ɵm, HeaderLogoMiniComponent as ɵn, HeaderComponent as ɵo, SidebarLeftModule as ɵp, AnimationsModule as ɵq, CollapseAnimationDirective as ɵr, SidebarLeftComponent as ɵs, SidebarLeftToggleDirective as ɵt, WrapperService as ɵu, SidebarRightModule as ɵv, SidebarRightComponent as ɵw, WrapperModule as ɵx, WrapperComponent as ɵy, LayoutConfigToken as ɵz };
//# sourceMappingURL=angular-admin-lte.js.map
